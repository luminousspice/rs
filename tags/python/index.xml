<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Python on the Right Stuff</title>
    <link>http://rs.luminousspice.com/tags/python/</link>
    <description>Python | the Right Stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Fri, 17 Jan 2014 22:55:53 +0900</lastBuildDate>
    <atom:link href="https://pubsubhubbub.superfeedr.com" rel="hub"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <atom:link href="http://rs.luminousspice.com/tags/python/index.xml" rel="self" type="application/rss+xml" />
    
    <item>
      <title>フックを使った Anki アドオンのつくり方</title>
      <link>http://rs.luminousspice.com/how_to_create_anki_add-ons/</link>
      <pubDate>Fri, 17 Jan 2014 22:55:53 +0900</pubDate>
      <guid>http://rs.luminousspice.com/how_to_create_anki_add-ons/</guid>
      <description>Anki は、アドオンを作成することで、標準機能を拡張したり、変更したりすることが出来ます。このアドオンの作成を簡単にするために、Anki はフック (Hook) という機能を提供しています。Anki の本体機能にカスタムのフックを追加し、機能拡張するアドオンを作成する方法を簡単に説明します。復習後、熟知になったノートにタグを付けるアドオンを開発します。Simple tutorial to create Anki Add-ons for developer with an custom hook.</description>
      <content>&lt;section id=&#34;preamble&#34;&gt;
&lt;p&gt;Anki は、アドオンを作成することで、標準機能を拡張したり、変更したりすることができます。このアドオンの作成を簡単にするために、Anki はフック (Hook) という機能を提供しています。フックを使うと標準機能の中に簡単に外部の関数を組み込むことができます。この記事では更に進んで Anki の標準のフックがない場所にカスタムのフックを追加し、機能拡張するアドオンを作成する方法を簡単に説明します。復習後、熟知になったノートにタグを付けるアドオンを開発します。オフィシャルドキュメント「Anki 2.0 アドオンの作成」を補足する内容です。&lt;/p&gt;
&lt;p&gt;この記事は、АnkiWeb に公開済みの Аnki アドオン (Add-on) &lt;a href=&#34;https://ankiweb.net/shared/info/1299246957&#34; target=&#34;_new&#34;&gt;Mature Tag&lt;/a&gt;を例にとって、解説します。
完成品をインストールして動作させることができますし、ソースコードを見ることもできます。最後に作成したアドオンを AnkiWeb の共有アドオン一覧に登録する方法を紹介します。&lt;/p&gt;
&lt;p&gt;アドオンのインストール方法は、&lt;a href=&#34;http://rs.luminousspice.com/how-to-use-shared-resources/&#34;&gt;Ankiの共有リソースを使ってみる&lt;/a&gt;で紹介しています。&lt;/p&gt;
&lt;p&gt;また、ソースコードの表示方法は、インストールが完了した後、メニューバーの[ツール]-[アドオン]-[Mature_Tag]-[編集&amp;#8230;]を選択してください。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;前提知識&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;前提知識&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;この記事の内容を理解するには、次の知識が必要です。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
Anki の操作方法
特に、Anki というアプリケーションの機能を十分理解した上での操作方法の習熟は必須です。
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
Python による開発経験
他の開発言語の経験でも構いませんが、自分で資料を読み Python の開発方法を学べる能力は必要です。
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://rs.luminousspice.com/anki2addons/&#34;&gt;Anki 2.0 アドオンの作成&lt;/a&gt;の内容理解
本文中のサンプルコードを実際に動かしてアドオンを作成する経験があると理解に役立ちます。
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;この記事の最後に &lt;a href=&#34;http://rs.luminousspice.com/how_to_create_anki_add-ons/#review&#34;&gt;Anki アドオン開発のおさらい&lt;/a&gt; という項目を設けて、必要な知識をまとめています。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;つくるアドオンの要件&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;つくるアドオンの要件&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;まず最初にアドオンの要件を決めておきます。&lt;/p&gt;
&lt;p&gt;「復習が終わったら、新たに設定した復習間隔を調べ、熟知なら &#34;Mature&#34; というタグをノートに追加し、それ以外なら  &#34;Mature&#34; を削除します。」&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;モジュールのインポート&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;モジュールのインポート&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;最初に必要なモジュールをインポートします。
Anki の復習で解答した時の処理は &lt;a href=&#34;https://github.com/dae/anki/blob/master/anki/sched.py&#34; target=&#34;_new&#34;&gt;sched.py&lt;/a&gt; の中のクラス &lt;code&gt;Scheduler&lt;/code&gt; のメソッド &lt;code&gt;answerCard&lt;/code&gt; で記述しています。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;strong&gt;from&lt;/strong&gt; anki.sched &lt;strong&gt;import&lt;/strong&gt; Scheduler&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;残念ながら復習に関する処理の中にフック (Hook) は存在しません。そこで独自のフックをこのメソッドの最後に追加します。
フックの設置、呼び出しに必要なモジュールをインポートします。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;strong&gt;from&lt;/strong&gt; anki.hooks &lt;strong&gt;import&lt;/strong&gt; addHook, runHook, wrap&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;もちろん &lt;code&gt;answerCard&lt;/code&gt; を書き換えることもできますが、今回の様な条件では独自フックの設置したほうが簡単に記述できます。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;復習の解答後に処理するフックを設置する&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;復習の解答後に処理するフックを設置する&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;&lt;/p&gt;
&lt;p&gt;まず、独自のフック &#34;anseweredRevCard&#34; を追加する関数 &lt;code&gt;newAnswerCard()&lt;/code&gt; を定義します。
runHook() はフックを新たに設置する標準の関数です。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;strong&gt;def&lt;/strong&gt; newAnswerCard(self, card, ease):
    runHook(&#39;anseweredRevCard&#39;, self, card)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;次に標準の &lt;code&gt;wrap()&lt;/code&gt; 関数を使って、&lt;code&gt;answerCard&lt;/code&gt; の後に &lt;code&gt;newAnswerCard&lt;/code&gt; の内容を追加する処理を記述します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;Scheduler.answerCard = wrap(Scheduler.answerCard, newAnswerCard)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;すると &lt;code&gt;answerCard&lt;/code&gt; の最後に次の行が追加されます。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;runHook(&#39;anseweredRevCard&#39;, self, card)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで、復習で解凍した後に処理を呼び出すフックを設置できました。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;タグを追加_削除する&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;タグを追加、削除する&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;復習が終わったら、復習間隔を調べ 21 日以上であったら、&#34;Mature&#34; タグを追加し、それ以外の場合は削除する関数　&lt;code&gt;matureCheck()&lt;/code&gt; を定義します。
熟知の基準日数は変数 &lt;code&gt;threshold&lt;/code&gt; に、設定するタグ文字列は変数 &lt;code&gt;MatureTag&lt;/code&gt; に設定しました。
タグをノートに追加するには &lt;code&gt;Note&lt;/code&gt; クラスのメソッド &lt;code&gt;addTag()&lt;/code&gt; を、削除するには &lt;code&gt;delTag()&lt;/code&gt; を使います。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;i&gt;# Threshold interval for tagging&lt;/i&gt;
threshold = 21
&lt;i&gt;# Tag string for mature note&lt;/i&gt;
MatureTag = u&#34;Mature&#34;

&lt;strong&gt;def&lt;/strong&gt; matureCheck(self, card):
    f = card.note()
    &lt;strong&gt;if&lt;/strong&gt; (card.ivl &amp;gt;= threshold):
        f.addTag(MatureTag)
    &lt;strong&gt;else&lt;/strong&gt;:
        f.delTag(MatureTag)
    f.flush()
    &lt;strong&gt;return&lt;/strong&gt; True&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;最後に &lt;code&gt;addHook()&lt;/code&gt; 関数を使って上で作成したカスタムフック &#34;anseweredRevCard&#34;　で &lt;code&gt;matureCheck()&lt;/code&gt; 関数を呼び出す設定をします。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;addHook(&#34;anseweredRevCard&#34;, matureCheck)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;これで、完成です。完成品は次の通りです。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;strong&gt;from&lt;/strong&gt; anki.hooks &lt;strong&gt;import&lt;/strong&gt; addHook, runHook, wrap
&lt;strong&gt;from&lt;/strong&gt; anki.sched &lt;strong&gt;import&lt;/strong&gt; Scheduler

&lt;i&gt;# Threshold interval for tagging&lt;/i&gt;
threshold = 21
&lt;i&gt;# Tag string for mature note&lt;/i&gt;
MatureTag = u&#34;Mature&#34;

&lt;strong&gt;def&lt;/strong&gt; matureCheck(self, card):
    f = card.note()
    &lt;strong&gt;if&lt;/strong&gt; (card.ivl &amp;gt;= threshold):
        f.addTag(MatureTag)
    &lt;strong&gt;else&lt;/strong&gt;:
        f.delTag(MatureTag)
    f.flush()
    &lt;strong&gt;return&lt;/strong&gt; True

&lt;strong&gt;def&lt;/strong&gt; newAnswerCard(self, card, ease):
    runHook(&#39;anseweredRevCard&#39;, self, card)

Scheduler.answerCard = wrap(Scheduler.answerCard, newAnswerCard)

addHook(&#34;anseweredRevCard&#34;, matureCheck)&lt;/pre&gt;&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&#34;もっとかんたんに書く&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;もっとかんたんに書く&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;実は、フックを設置せずに記述を簡略化できます。メソッドを上書きする方法です。
&lt;code&gt;wrap()&lt;/code&gt; 関数で直接 &lt;code&gt;matureCheck&lt;/code&gt; を指定します。&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;- &lt;strong&gt;def&lt;/strong&gt; newAnswerCard(self, card, ease):
-    runHook(&#39;anseweredRevCard&#39;, self, card)

- Scheduler.answerCard = wrap(Scheduler.answerCard, newAnswerCard)
+ Scheduler.answerCard = wrap(Scheduler.answerCard, matureCheck)

- addHook(&#34;anseweredRevCard&#34;, matureCheck)&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;この場合は、フックを使わないので、他の関数も追加で呼び出すような追加拡張はできません。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;ファイルの配置&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;ファイルの配置&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;完成したファイル Mature_Tag.py を動作させるには、&lt;code&gt;Documents/Anki/addons&lt;/code&gt; フォルダの中に保存します。Anki を再起動すると、この Python スクリプトファイルを読み込みます。&lt;/p&gt;
&lt;p&gt;アドオンが読み込まれるとメニューバーに [ツール]-[アドオン]-[Mature_Tag] という項目が追加されます。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;ankiweb_の共有アドオン一覧に登録する&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;AnkiWeb の共有アドオン一覧に登録する&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;作成したアドオンを AnkiWeb に公開して、アドオン一覧に登録する方法を紹介します。
まず、&lt;a href=&#34;https://ankiweb.net/shared/addons/&#34; target=&#34;_new&#34;&gt;共有アドオン一覧&lt;/a&gt;を開き、AnkiWeb にサインインします。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/anki_addon_tutorial_1.png&#34; alt=&#34;アドオン一覧&#34; width=&#34;60%&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 1. 共有アドオン一覧&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;登録フォームは画面右上の [Upload Add-on] ボタンをクリックすると表示します。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/anki_addon_tutorial_2.png&#34; alt=&#34;登録フォーム&#34; width=&#34;60%&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 2. アドオン登録フォーム&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;このフォームでは次のように項目入力します。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;strong&gt;Title:&lt;/strong&gt; アドオンの名前を入力します。アドオン一覧に表示する名前にになります。
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;strong&gt;File:&lt;/strong&gt; 登録したいアドオンの Python スクリプトを選択します。今回の例では &lt;code&gt;Mature_Tag.py&lt;/code&gt; です。
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;strong&gt;Description&lt;/strong&gt; アドオンユーザーのためにアドオンの機能や使い方の説明を入力します。
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;入力が済んだら [Upload] を押すと登録できます。特に AnkiWeb に障害がなければ即座に公開されます。
登録したアドオンのページに移動します。&lt;/p&gt;
&lt;p&gt;公開したアドオンのページの下にある [Update] ボタンを押すと登録内容の編集ができ、[Remove] ボタンを押すとアドオンを削除することができます。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/anki_addon_tutorial_3.png&#34; alt=&#34;アドオンページ 編集、削除ボタン&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 3. アドオンページ 編集、削除ボタン&lt;/div&gt;
&lt;/div&gt;
&lt;/section&gt;
&lt;section id=&#34;まとめ&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;まとめ&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;「Anki 2.0 アドオンの作成」で説明しているとおり、Anki が標準で用意しているフックを利用すると Anki の機能の修正や追加が簡単になります。フックが用意されていない箇所にも、この記事で紹介した方法で自分でカスタムのフックを自由に追加することができます。フックの使い方になれると Anki アドオン作成するを能力が向上し、Anki 自身の機能についても理解を深めることができます。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;review&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;遺補: Anki アドオン開発のおさらい&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;Anki のアドオンは、Python スクリプトで記述し、&lt;code&gt;Documents/Anki/addons&lt;/code&gt; フォルダの中に保存します。
Anki に Python インタープリタが含まれているため、アドオンの開発に Python のインストールは必要ありません。&lt;/p&gt;
&lt;p&gt;Anki は起動時に &lt;code&gt;addons&lt;/code&gt; フォルダの中の &lt;code&gt;.py&lt;/code&gt; ファイルを読み込みます。
従って、新たにアドオンファイルを追加した場合、再起動して初めて機能するようになります。
なお、シフトキーを押したまま Anki を起動すると、アドオンファイルの読み込みは行いません。&lt;/p&gt;
&lt;p&gt;Anki には、WordPress のようにフック (Hook) という機能を提供していて、標準機能を拡張したり、変更したりするアドオン開発が容易にできます。Anki 自身もたくさんのフックを利用しています。&lt;/p&gt;
&lt;p&gt;アドオンをつくるために Anki が用意している関数は次の通りです。&lt;/p&gt;
&lt;table rules=&#34;rows&#34; frame=&#34;hsides&#34;cellspacing=&#34;0&#34; cellpadding=&#34;4&#34;&gt;
&lt;caption class=&#34;title&#34;&gt;表 1. アドオン開発用関数&lt;/caption&gt;
&lt;colgroup&gt;
&lt;col class=&#34;span1&#34;&gt;
&lt;col class=&#34;span4&#34;&gt;
&lt;/colgroup&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;関数名&lt;/th&gt;
&lt;th&gt;説明&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;
&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;runHook&lt;/td&gt;
&lt;td&gt;フックを実行する。値は返さない。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;runFilter&lt;/td&gt;
&lt;td&gt;フィルターを実行し値を返す。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;addHook&lt;/td&gt;
&lt;td&gt;フックを追加する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;remHook&lt;/td&gt;
&lt;td&gt;フックを削除する。&lt;/td&gt;
&lt;/tr&gt;
&lt;tr&gt;
&lt;td&gt;wrap&lt;/td&gt;
&lt;td&gt;既存の関数を上書きする。第3引数でオリジナルの関数の位置を指定。既定はオリジナルの後にカスタム関数を実行する。&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;
&lt;p&gt;フックを見つけるには、Anki のソースコードを　&#34;runHook&#34;、&#34;runFilter&#34; で検索します。Anki 2.0.20 現在　36 のフックが存在します。&lt;/p&gt;
&lt;p&gt;フックの使い方を詳しく知るには、&lt;a href=&#34;http://rs.luminousspice.com/anki2addons/&#34;&gt;Anki 2.0 アドオンの作成&lt;/a&gt;、および &lt;a href=&#34;https://github.com/dae/anki/blob/master/anki/hooks.py&#34; target=&#34;_new&#34;&gt;anki/hooks.py&lt;/a&gt; をお読みください。&lt;/p&gt;
&lt;/section&gt;
</content>
    </item>
    
    <item>
      <title>Mac OS X に IPython Notebook をインストールする場合の注意点</title>
      <link>http://rs.luminousspice.com/ipython-notebook-installation-on-macosx/</link>
      <pubDate>Mon, 02 Dec 2013 00:00:49 +0900</pubDate>
      <guid>http://rs.luminousspice.com/ipython-notebook-installation-on-macosx/</guid>
      <description>IPython Notebook を Mac OS X にインストールする際に発生する、matplotlib のインストールの問題を解決する方法を紹介します。</description>
      <content>&lt;section id=&#34;preamble&#34;&gt;
&lt;p&gt;IPython Notebook を Mac OS X にインストールする際に発生する、matplotlib のインストールの問題を解決する方法を紹介します。&lt;/p&gt;
&lt;p&gt;この記事は、Mac OS X 10.7 上に virtualenv で構築した Python 2.7.5 の仮想環境に IPython 1.1.0 をインストールする場合の注意点を取り上げます。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://ipython.org/notebook.html&#34; target=&#34;_new&#34;&gt;IPython Notebook&lt;/a&gt; は、Python の対話的な Web ベースの使いやすいシェルで、グラフや数式を表示することができます。特に Python の科学計算パッケージを利用する場合に重宝します。
IPython のオフィシャルサイトで紹介している Anaconda という Python の商用配布パッケージには、IPython と関連パッケージが全て含まれていて、簡単にインストール可能です。&lt;/p&gt;
&lt;p&gt;しかしながら、既に Python の独自環境を構築していて、追加で IPython Notebook のインストールには、複数の Python パッケージをインストールする必要があります。
Mac OS X 環境に IPython Notebook インストールする手順としては、 &lt;a href=&#34;http://slowquery.hatenablog.com/entry/2013/04/01/010927&#34; target=&#34;_new&#34;&gt;IPython notebookでブラウザ内にグラフを描画する&lt;/a&gt; などの記事が参考になります。&lt;/p&gt;
&lt;p&gt;ただし Mac OS X の場合、&lt;code&gt;pip install matplotlib&lt;/code&gt; だけでは、matplotlib がインストールできず、IPython 実行後のグラフの描画の際にエラーが発生する場合があります。&lt;/p&gt;
&lt;p&gt;これは、Stack Overflow の投稿 &lt;a href=&#34;http://superuser.com/questions/242190/how-to-install-matplotlib-on-os-x&#34; target=&#34;_new&#34;&gt;How to install matplotlib on OS X?&lt;/a&gt; によれば、Mac OS X の場合、matplotlib をインストールする前に、コンパイルオプションを指定すると解決できるそうです。&lt;/p&gt;
&lt;p&gt;pip を使う場合は、次のように実行します。&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;LDFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;-L/usr/X11/lib&amp;quot;&lt;/span&gt;
&lt;span class=&#34;nb&#34;&gt;export &lt;/span&gt;&lt;span class=&#34;nv&#34;&gt;CFLAGS&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;=&lt;/span&gt;&lt;span class=&#34;s2&#34;&gt;&amp;quot;-I/usr/X11/include -I/usr/X11/include/freetype2 -I/usr/X11/include/libpng12&amp;quot;&lt;/span&gt;
pip install matplotlib
&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;インストール終了後、再度グラフを描画して、確認すれば作業完了です。&lt;/p&gt;
&lt;/section&gt;
</content>
    </item>
    
    <item>
      <title>静的サイトジェネレータ Pelican で AsciiDoc を使う方法</title>
      <link>http://rs.luminousspice.com/pelican_with_asciidoc/</link>
      <pubDate>Sun, 01 Dec 2013 21:00:53 +0900</pubDate>
      <guid>http://rs.luminousspice.com/pelican_with_asciidoc/</guid>
      <description>静的サイトジェネレータ Plican で AsciiDoc を機能させるのに必要な、文書化されていない作業をまとめました。</description>
      <content>&lt;section id=&#34;preamble&#34;&gt;
&lt;p&gt;静的サイトジェネレータ Plican で AsciiDoc を機能させるのに必要な、文書化されていない作業をまとめました。AsciiDoc API  のインストール方法と、日本語を処理した時に発生するユニコードエラーの対応について説明しています。&lt;/p&gt;
&lt;p&gt;&lt;a href=&#34;http://docs.getpelican.com/&#34;&gt;Pelican&lt;/a&gt; は、Python で書かれた静的なサイトジェネレータです。reStructuredText や Markdown を標準でサポートしています。&lt;/p&gt;
&lt;p&gt;マークアップ言語に &lt;a href=&#34;http://www.methods.co.nz/asciidoc/&#34;&gt;AsciiDoc&lt;/a&gt; を利用するために必要な、文書化されていない手続について説明します。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;asciidoc_api_のインストール&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;AsciiDoc API のインストール&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;Pelican で AsciiDoc を利用するには、&lt;a href=&#34;http://www.methods.co.nz/asciidoc/asciidocapi.html&#34;&gt;AsciiDoc API&lt;/a&gt; をインストールする必要があります。
Markdown を利用するには pip を使ったインストールが可能ですが、AsciiDoc の場合は別途作業になります。&lt;/p&gt;
&lt;p&gt;AsciiDoc API は &lt;code&gt;asciidocapi.py&lt;/code&gt; ファイルの形で提供されています。Sourceforge から &lt;a href=&#34;http://sourceforge.net/projects/asciidoc/&#34;&gt;AsciiDoc のソースコード&lt;/a&gt;のアーカイブを解凍するとトップレベルに &lt;code&gt;asciidocapi.py&lt;/code&gt; が見つかります。&lt;/p&gt;
&lt;p&gt;私の環境は、virtualenv を使っていますので次の場所にインストールしました。
&lt;code&gt;~/.virtualenvs/(Pelicanを使う仮想環境名)/bin/asciidocapi.py&lt;/code&gt;&lt;/p&gt;
&lt;p&gt;これで、ドキュメントのファイル名の拡張子を &lt;code&gt;asc&lt;/code&gt; にすると、Pelican は AsciiDoc として認識し処理してくれます。&lt;/p&gt;
&lt;/section&gt;
&lt;section id=&#34;ユニコードエラーの問題&#34;&gt;
  &lt;div class=&#34;page-header&#34;&gt;
    &lt;h2&gt;ユニコードエラーの問題&lt;/h2&gt;
  &lt;/div&gt;
&lt;p&gt;利用している Python 環境によっては、Pelican で日本語の文書を処理した時にユニコードのエラーが発生することがあります。これは既定のエンコーディングが utf-8 になっていないためです。&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;WARNING: Could not process ./mydoc.asc
&lt;span class=&#34;s1&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt; codec can&amp;#39;t encode characters in position 20-22: ordinal not in range&lt;span class=&#34;o&#34;&gt;(&lt;/span&gt;128&lt;span class=&#34;o&#34;&gt;)&lt;/span&gt;
Done: Processed 1 articles and 0 pages in 0.40 seconds.
&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;次のように、調べると既定のエンコーディングを調べることができます。&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.getdefaultencoding&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;s1&#34;&gt;&amp;#39;ascii&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;asciidocapi.py を書き換える方法と、Python の環境設定ファイルを編集する方法があります。Python の配布用モジュールを開発している訳ではないので、今回は環境設定ファイルで対応しました。&lt;/p&gt;
&lt;p&gt;設定は &lt;code&gt;sitecustomize.py&lt;/code&gt; を編集します。
このファイルのありか次のように調べます。&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; import sitecustomize
&amp;gt;&amp;gt;&amp;gt; sitecustomize.__file__
&lt;span class=&#34;s1&#34;&gt;&amp;#39;/usr/local/lib/python2.7/site-packages/sitecustomize.pyc&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;このファイルに次のような記述を追加します。&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&lt;span class=&#34;kn&#34;&gt;import&lt;/span&gt; &lt;span class=&#34;nn&#34;&gt;sys&lt;/span&gt;
&lt;span class=&#34;n&#34;&gt;sys&lt;/span&gt;&lt;span class=&#34;o&#34;&gt;.&lt;/span&gt;&lt;span class=&#34;n&#34;&gt;setdefaultencoding&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;(&lt;/span&gt;&lt;span class=&#34;s&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;&lt;span class=&#34;p&#34;&gt;)&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;最後に、既定の設定が反映されているか確認します。次のように utf-8 になっていれば完了です。&lt;/p&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;&lt;div class=&#34;highlight&#34;&gt;&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; import sys
&amp;gt;&amp;gt;&amp;gt; sys.getdefaultencoding&lt;span class=&#34;o&#34;&gt;()&lt;/span&gt;
&lt;span class=&#34;s1&#34;&gt;&amp;#39;utf-8&amp;#39;&lt;/span&gt;
&lt;/pre&gt;&lt;/div&gt;&lt;/div&gt;&lt;/div&gt;
&lt;p&gt;文書化されていない Pelican での AsciiDoc 利用の方法はここまでです。
ここから先は、他のマークアップ言語と同じようにドキュメントの内容に従って使いこなしてください。&lt;/p&gt;
&lt;/section&gt;
</content>
    </item>
    
    <item>
      <title>MSDN Magazine過去10年分の頻出語彙からAnki単語帳を作る</title>
      <link>http://rs.luminousspice.com/frequent-words-in-msdn-magazine-in-10years/</link>
      <pubDate>Fri, 07 Jun 2013 22:30:38 +0900</pubDate>
      <guid>http://rs.luminousspice.com/frequent-words-in-msdn-magazine-in-10years/</guid>
      <description>以前の記事では、過去3年分のMSDN Magazineの記事のコーパス分析から頻出語彙表を作成し、Anki単語帳に加工する方法を紹介しました。前回手をつけなかったCHMファイルをコーパスに取り込み過去10年に遡った分析し [&amp;hellip;]</description>
      <content>&lt;section id=&#34;msdn_magazine過去10年分の頻出語彙からanki単語帳を作る&#34;&gt;
&lt;p&gt;以前の記事では、過去3年分のMSDN Magazineの記事のコーパス分析から頻出語彙表を作成し、Anki単語帳に加工する方法を紹介しました。前回手をつけなかったCHMファイルをコーパスに取り込み過去10年に遡った分析します。前回作成したMSDN Word Listからの差分は102語になりました。&lt;/p&gt;
&lt;div class=&#34;sidebarblock well&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://ankisrs.net/&#34;&gt;Anki&lt;/a&gt;とはDamien Elmesが開発している分散学習システム(SRS; Spaced Repetition learning Systems)です。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&#34;おことわり&#34; class=&#34;section&#34;&gt;おことわり&lt;/h2&gt;
&lt;div class=&#34;sidebarblock well&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;p&gt;この記事は、楽しむことを目的とした内容で、学術的な厳密性を考慮していません。&lt;/p&gt;
&lt;p&gt;MSDNは、Microsoft Corporationの商標であり、
MSDN Magazineは、1105 Media, Inc.の出版物です。&lt;/p&gt;
&lt;/div&gt;&lt;/div&gt;
&lt;h2 id=&#34;使うもの&#34; class=&#34;section&#34;&gt;使うもの&lt;/h2&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://ankisrs.net/&#34;&gt;Anki2&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://msdn.microsoft.com/en-us/magazine/default.aspx&#34;&gt;MSDN Magazine&lt;/a&gt; BackNumber 2003.01 - 2009.07
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
コンコーダンサーソフト (この記事の作成には、&lt;a href=&#34;https://sites.google.com/site/casualconcj/Home&#34;&gt;CasualConc&lt;/a&gt;を使いました。)
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
表計算ソフト (この記事の作成には、&lt;a href=&#34;http://ja.libreoffice.org/&#34;&gt;LibreOffice Calc&lt;/a&gt;を使いました。)
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;h2 id=&#34;はじめに&#34; class=&#34;section&#34;&gt;はじめに&lt;/h2&gt;
&lt;p&gt;以前の記事、&lt;a href=&#34;http://rs.luminousspice.com/frequent-words-in-msdn/&#34;&gt;Windows開発者の必修語彙をAnki学習する方法&lt;/a&gt;ではMSDN MagazineのバックナンバーのうちPDF化されている過去3年分について、コーパス分析を行いました。
コンコーダンサーソフトに読み込む作業の煩雑さから、CHM(Microsoft Compiled HTML Help)形式のファイルは対象としませんでした。&lt;/p&gt;
&lt;p&gt;今回は、CHMファイルをPDFに変換してコンコーダンサーに読み込む方法に挑戦します。&lt;/p&gt;
&lt;p&gt;2003年のバックナンバーを改めて読んでみました。.NET Framework 1.1とWindows XP SP2(Springboard)という現在のWindowsプラットフォームの基盤となる製品がリリースした頃です。ここまで遡ってコーパスデータを分析すれば、ほぼWindowsプラットフォームの技術文書に特有な語彙は網羅できるだろうと考えました。&lt;/p&gt;
&lt;p&gt;内容の面での代表性を考えるとSpringboardまで遡らないと不十分なのではと、気になっていました。&lt;/p&gt;
&lt;p&gt;CHMファイル数は79で、今回の拡張で前回の分析データから3倍に増加します。&lt;/p&gt;
&lt;p&gt;分析前の予想として、高頻度の語彙の使用がさらに集中して、使用語彙の98%に入る頻出語彙の種類は減るだろうというと考えています。実際に確認してみました。&lt;/p&gt;
&lt;h2 id=&#34;chmファイルの変換&#34; class=&#34;section&#34;&gt;CHMファイルの変換&lt;/h2&gt;
&lt;p&gt;CHMファイルを分解して取り出す正統的な方法は&lt;a href=&#34;http://msdn.microsoft.com/en-us/library/ms669985.aspx&#34;&gt;Help Workshop&lt;/a&gt;を使う方法です。この方法だと手作業の部分が非常に多くなるため二の足を踏んでいました。&lt;/p&gt;
&lt;p&gt;なにかCHMファイルをコンバートする上手い方法はないだろうかと探していたところ、pdfに変換してくれるアプリケーションが見つかりました。&lt;a href=&#34;http://code.google.com/p/ichm/&#34;&gt;iChm&lt;/a&gt;というMac OS X上のCHMビューアーと&lt;a href=&#34;http://code.google.com/p/chm2pdf/&#34;&gt;chm2pdf&lt;/a&gt;という変換用Pythonスクリプトです。&lt;/p&gt;
&lt;p&gt;心情的にはchm2pdfを使って、シェルスクリプトで一括処理したかったのですが、MSDN Magazineの1冊分のファイル容量では大きすぎて、chm2pdfはエラーをはきます。そこで残念ながら79個のファイルを手作業でiChmを使って、pdfに書き出しました。&lt;/p&gt;
&lt;p&gt;なお、chm2pdfのMac OS X上でのビルド方法について情報がインターネット上にほとんどなかったので、この記事の最後に補足として記録しておきます。&lt;/p&gt;
&lt;h2 id=&#34;コンコーダンサーcasualconcへの読み込み&#34; class=&#34;section&#34;&gt;コンコーダンサーCasualConcへの読み込み&lt;/h2&gt;
&lt;p&gt;pdf化したバックナンバーをCasualConcで既存のコーパスデータベースに追加します。
前回はデータベースの新規作成を行いましたが、今回はデータの追加なので作業手順が若干異なります。&lt;/p&gt;
&lt;p&gt;今回のデータを別のデータベースとして新規作成する方法もあります。手順は前回と同じです。
この場合は、頻度表をカウントする時に複数のデータベースを指定する必要があります。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/msdnwl1.png&#34; alt=&#34;ファイルツール&#34; width=&#34;600&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 1. CasualConc ファイルツール画面&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;コーパス作成手順 (図1)&lt;/div&gt;
&lt;ol&gt;
&lt;li&gt;
画面上[ファイル]タブをクリックしてファイルツールを表示する。
&lt;/li&gt;
&lt;li&gt;
右上画面下[追加]ボタンでコーパス化するファイルを選択する。
&lt;/li&gt;
&lt;li&gt;
左下画面下[追加リストから追加]ボタンを押すとコーパスが作成できます。
&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;ここで、登録済みのデータを重複して登録するかというダイアログが表示される場合があります。ディレクトリ内に以前作業したファイルが残っている場合などですが、[すべていいえ]を選択してください。&lt;/p&gt;
&lt;p&gt;その後の手順は、&lt;a href=&#34;http://rs.luminousspice.com/frequent-words-in-msdn/&#34;&gt;Windows開発者の必修語彙をAnki学習する方法&lt;/a&gt;の通りです。&lt;/p&gt;
&lt;h2 id=&#34;10年分に対象を拡大した結果&#34; class=&#34;section&#34;&gt;10年分に対象を拡大した結果&lt;/h2&gt;
&lt;p&gt;頻度順に語彙を並べて、コーパス全体に占める割合を足していくと2754番目に98%に達します。登場回数は77が最小値です。
そこから、一般的に高頻度な語彙(GSL+BNC2K)と学術的に高頻度な語彙を除き、MSDN Magazineに特有な頻出語彙662語を抽出しました。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/msdnwl10y1.png&#34; alt=&#34;MSDN Magazine コーパスの内訳&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 2. MSDN Magazine 過去10年分の使用語彙の内訳&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;さて、最初の予想はどうなったかというと、直近3年分の分析結果から180語が外れて、100語が追加になりました。&lt;/p&gt;
&lt;p&gt;10年のスパンで見ると頻出語句だけど、この3年では頻出語句からものは、gadget、cursor、virus、KB、LOB、fuzzy、RPC、enumeratorなどが含まれていて、時代を感じさせる言葉です。
この3年で頻出語句に入ってきたものは、geographic、multicore、affiliate、gpu、ubiquitous、taxonomy、prototypeなどです。SEOなどのバズワードも入っています。&lt;/p&gt;
&lt;p&gt;技術の進歩や市場の関心の変化が反映していることが読み取れました。&lt;/p&gt;
&lt;p&gt;当初は、10年分の分析結果の語彙表を決定版として、3年分のデータを置き換えようと考えていました。
多くのコーパス分析の対象は、過去に向いて文学作品など固定した文書ですが、今自分が扱っているのは生ものの文字情報なのだということに気づきました。&lt;/p&gt;
&lt;p&gt;未来に向けて、予言する訳ではないですが、これから出てくるであろう文書を読むための語彙を調べようという趣旨なので、直近3年分のデータを正本として、10年分のデータは補足資料として扱おうと方針転換しました。
ほとんど無駄な努力だったかもです。この脱力感がたまらない。同時に直近3年分のデータからの結果に自信を持ちました。&lt;/p&gt;
&lt;p&gt;直近3年の頻出語句からもれた102語を補足データとして、&lt;a href=&#34;http://ankisrs.net/&#34;&gt;Anki&lt;/a&gt;単語帳のパッケージデータにしました。Level3というタグを付加しています。&lt;/p&gt;
&lt;h2 id=&#34;完成品のダウンロード&#34; class=&#34;section&#34;&gt;完成品のダウンロード&lt;/h2&gt;
&lt;p&gt;この記事で作成した差分の単語帳は、&lt;a href=&#34;http://rs.luminousspice.com/apkg/msdnwl_adx.apkg&#34;&gt;Anki単語帳パッケージ msdnwl_adx.apkg (15.2KB)&lt;/a&gt;をダウンロードしてお使いいただけます。
子単語帳`MSDNWords::Level3`として作成していますので、既にダウンロード済みの単語帳に追加して使うことができます。&lt;/p&gt;
&lt;p&gt;全体の単語帳は、&lt;a href=&#34;http://nossl.ankiweb.net/shared/download/722400168&#34; rel=&#34;nofollow&#34; onclick=&#34;ga(&#39;send&#39;, &#39;event&#39;, &#39;Downloads&#39;, &#39;AKPG&#39;, &#39;MSDNワードリスト&#39;);&#34;&gt;Anki単語帳パッケージ&lt;/a&gt;をダウンロードしてお使いいただけます。&lt;/p&gt;
&lt;p&gt;この単語帳を使うにはAnkiのインストールが必要です。&lt;a href=&#34;http://ankisrs.net/&#34;&gt;Ankiサイト&lt;/a&gt;から最新版をダウンロードできます。Ankiは、Windows、Mac、Linux/BSD、iOS、Androidに対応しています。その他のデバイスからはAnkiWebを通じて利用可能です。詳しくはAnkiサイトをご覧ください。&lt;/p&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/msdnwl10y2.png&#34; alt=&#34;完成品画面&#34; width=&#34;400&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 3. 完成品画面&lt;/div&gt;
&lt;/div&gt;
&lt;p&gt;このAnki単語帳の使い方については、&lt;a href=&#34;http://rs.luminousspice.com/frequent-words-in-msdn/&#34;&gt;Windows開発者の必修語彙をAnki学習する方法&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;h2 id=&#34;まとめ&#34; class=&#34;section&#34;&gt;まとめ&lt;/h2&gt;
&lt;p&gt;テキストデータをより広範に収集できれば、頻度表の品質を向上させることができます。
その際には目的にかなった対象を選ぶことが大切です。&lt;/p&gt;
&lt;p&gt;当初の目論みから方針転換はしましたが、取得したデータの内容から、この分野の頻出語彙集の決定版だと思っています。&lt;/p&gt;
&lt;p&gt;個人としてできることは、あとはSDKのドキュメントなどからコーパスデータを作って個別製品の開発に特化したより分野の狭い専門語彙を見つけ出すことだと思います。
全てのSDKドキュメントを集めて、合算して分析する発想もありますが、今回の結果と大きな差でないのではないかと思います。
但し、全SDKドキュメントのコーパスの作成は、今回の様な頻出語彙を取り出すのではなくて、もっと広範で高度なコーパス分析には意義があると思います。&lt;/p&gt;
&lt;p&gt;頻度表を得るために作ったコーパスをKWIC分析やN-gram分析を掛けると、その語彙の語義だけでは分からない、MSDNのコンテキストの中での、その語彙の振る舞いが一覧にして理解できるようになります。この情報は語彙学習の面で極めて強力でだと思います。サンプルのソースコードも一緒に見ることができます。&lt;/p&gt;
&lt;p&gt;もし、自分でコーパスを作ってみた方は、ぜひ頻度表を作った後も、コーパスをメンテナンスして語彙学習に活用してみてください。楽しくなってくると思います。いつか機会があれば、そんな内容の記事が書けたら良いなと持っています。&lt;/p&gt;
&lt;p&gt;CasualConcは、PDF以外にも、HTML、XML、Web Archive、RTF、Microsoft Word、OASIS OpenDocument Textなどの直接的な読み込みをサポートしています。
テキストファイルへの変換が面倒な場合でも、上記のいずれかのフォーマットに持ち込めれば、コーパスを簡単に作成できます。&lt;/p&gt;
&lt;p&gt;また、複数のコーパスデータベースを管理して、データベース間にまたがって分析することも簡単にできます。&lt;/p&gt;
&lt;p&gt;自分の目的にあったデータを見つけ出して、もっと自由にAnkiを楽しんでください。&lt;/p&gt;
&lt;h2 id=&#34;補遺_chm2pdfのmac_os_xへのインストール方法&#34; class=&#34;section&#34;&gt;補遺 chm2pdfのMac OS Xへのインストール方法&lt;/h2&gt;
&lt;p&gt;Pythonスクリプト&lt;a href=&#34;http://code.google.com/p/chm2pdf/&#34;&gt;chm2pdf&lt;/a&gt;の前提条件は次の3点です。&lt;/p&gt;
&lt;div class=&#34;ulist&#34;&gt;&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;https://github.com/jedwing/CHMLib&#34;&gt;chmlib&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
&lt;a href=&#34;http://gnochm.sourceforge.net/pychm.html&#34;&gt;pychm&lt;/a&gt;
&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;
htmldoc
&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;&lt;/div&gt;
&lt;p&gt;htmldocは、&lt;a href=&#34;http://brew.sh/&#34;&gt;Homebrew&lt;/a&gt;から入手できるので、chmlib、pychmのみ自力でインストールしました。
Pythonはシステムに付属しているものではなく、&lt;a href=&#34;https://github.com/utahta/pythonbrew&#34;&gt;pythonbrew&lt;/a&gt;からインストールしたPython 2.7.3を使いました。&lt;/p&gt;
&lt;h3 id=&#34;chmlib&#34;&gt;chmlib&lt;/h3&gt;
&lt;p&gt;Mac OS Xでのインストール方法が &lt;code&gt;INSTALL&lt;/code&gt; ファイルに書かれています。
更に、chm2pdfの &lt;code&gt;README&lt;/code&gt; に書かれている通り、 Makefileを作る時に `./configure --enable-examples`オプションが必要です。MacPortから入手できるものはこのオプションがないそうです。&lt;/p&gt;
&lt;h3 id=&#34;pychm&#34;&gt;pychm&lt;/h3&gt;
&lt;p&gt;pychmは、`README`に書かれている方法でインストールし、シェルの環境変数を設定します。&lt;/p&gt;
&lt;p&gt;最後にchm2pdfの &lt;code&gt;README&lt;/code&gt; に書いてある方法でインストールします。
ターミナルから次のように入力して使います。
&lt;code&gt;chm2pdf (--book / --webpage/) [options] input_filename [output_filename]&lt;/code&gt;&lt;/p&gt;
&lt;/section&gt;
</content>
    </item>
    
    <item>
      <title>Anki 2.0 アドオンの作成 日本語訳</title>
      <link>http://rs.luminousspice.com/anki2addons/</link>
      <pubDate>Sun, 16 Sep 2012 00:00:47 +0900</pubDate>
      <guid>http://rs.luminousspice.com/anki2addons/</guid>
      <description>Writing Anki 2.0 Add-ons  の日本語訳。簡単なサンプルを使ったアドオン作成の概要、データベースアクセスの方法、フックを使った既存コードのカスタマイズ、デバッグ、直前バージョン 1.2 のプラグインからの移行、アドオンの共有方法について説明しています。</description>
      <content>&lt;div id=&#34;preamble&#34;&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Writing Anki 2.0 Add-ons  の日本語訳。簡単なサンプルを使ったアドオン作成の概要、データベースアクセスの方法、フックを使った既存コードのカスタマイズ、デバッグ、直前バージョン 1.2 のプラグインからの移行、アドオンの共有方法について説明しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_日本語版をご覧いただく前に&#34;&gt;日本語版をご覧いただく前に&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この文書は、&lt;a href=&#34;http://ankisrs.net/docs/addons.html&#34;&gt;Writing Anki 2.0 Add-ons&lt;/a&gt; 2016-03-04 版の日本語訳です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.0 は 2016 年 5 月 1 日現在、最新バージョンは 2.0.36 です。より最新で正確な情報をご覧になりたい方は、原本をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;h1 id=&#34;_anki_2_0_アドオンの作成&#34; class=&#34;sect0&#34;&gt;Anki 2.0 アドオンの作成&lt;/h1&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_原文&#34;&gt;原文&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;英語: &lt;a href=&#34;http://ankisrs.net/docs/addons.html&#34; class=&#34;bare&#34;&gt;http://ankisrs.net/docs/addons.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_概要&#34;&gt;概要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は、ユーザーフレンドリーなプログラミング言語 Python で作成しています。
Python についてあまり詳しくない方は、この文書の先を読む前に
&lt;a href=&#34;http://docs.python.org/tutorial/&#34;&gt;Python tutorial&lt;/a&gt; をお読みください。
(訳注: &lt;a href=&#34;http://www.python.jp/doc/release/tutorial/index.html&#34;&gt;Python チュートリアル
日本語版&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Python は動的言語なため、Anki ではアドオンが極めて強力に機能します。アドオンは Anki の処理
を拡張するだけでなく、Anki の任意の側面に変更を加えることができます。例えば、スケジュール
設定の処理を変更したり、ユーザーインターフェイスを修正したりすることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;プラグインの開発には、特別な開発環境は必要ありません。テキストエディタがあれば十分です。
Windows や Mac をお使いの方は、このサイトで提供しているパッケージ版の Anki をお使いください。これらの
プラットフォーム上でゼロから Anki を構築するための説明が入手できないためです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;メモ帳のような単純なテキストエディタでプラグインを作成できますが、シンタックスハイライト
機能 (コードの色分け) を持ったエディタを探してみると、作業がより簡単になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki を構成する2つの要素&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;anki&#39; には、「背後」で動作する全てのコードが含まれています。コレクションを開いたり、
カードを取得し、回答する処理などです。これは、Anki の GUI が使用していますが、GUI を使わず
に Anki 単語帳にアクセスするコマンドラインプログラムに含めることもできます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;aqt&#39; には、Anki のユーザーインターフェイスの部分が含まれています。Anki のユーザー
インターフェイスは、PyQt 上に構築されています。PyQt とは、クロスプラットフォーム GUI
ツールキット Qt に対する Python バインディングです。PyQt は、Qt の API に密接に動作
します。&lt;a href=&#34;http://doc.qt.io/qt-4.8/index.html&#34;&gt;Qt documentation&lt;/a&gt; は、特定の GUI
コンポーネントの使い方を調べたい時に、非常に役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki が起動すると、Anki は、Documents/Anki/addons フォルダの中にある .py ファイルを
探し、見つけたら一つずつ実行します。アドオンが実行されると、通常は既存のコードを修正したり、
新しい機能を提供する新しいメニュー項目を増やしたりします。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_簡単なアドオンの一例&#34;&gt;簡単なアドオンの一例&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;次に示す test.py ファイルを、自分のアドオンフォルダーに追加してみてください:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;# aqt からメインウィンドウオブジェクト (mw) を読み込みます
from aqt import mw
# utils.py から &#34;show info&#34; ツールを読み込みます
from aqt.utils import showInfo
# Qt GUI ライブラリの全てを読み込みます
from aqt.qt import *

# 次のようなメニュー項目を追加してみましょう。まず最初にメニュー項目が利用可能になったら
# 呼び出す関数を作成します。

def testFunction():
    # 現在使用中のコレクションの中のカードの枚数を取得します
    # このコレクションはメインウィンドウの中に保存しています
    cardCount = mw.col.cardCount()
    # メッセージボックスを表示します
    showInfo(&#34;Card count: %d&#34; % cardCount)

# 新しいメニュー項目 &#34;test&#34; を作成します。
action = QAction(&#34;test&#34;, mw)
# この項目をクリックしたら testFunction を呼び出すように設定します。
mw.connect(action, SIGNAL(&#34;triggered()&#34;), testFunction)
# そして、この設定をツールメニューに反映します。
mw.form.menuTools.addAction(action)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki を再起動すると、ツールメニューの中に &#39;test&#39; 項目が追加されていることに気づくでしょう。
この項目を選択して実行するとカード枚数を表示するダイアログが現れます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;プラグインの入力中に間違いがあった場合には、Anki は起動時にエラーメッセージを表示して
どこに問題があるか指摘します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_コレクション&#34;&gt;コレクション&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;コレクションファイル上の全ての操作は、mw.col を通じてアクセスします。基本的な例で
何ができるがご紹介します。注意してほしいのは、上の例のように testFunction() の中で行ってください。
アドオンの中で直接実行することはできません。それは、Anki を起動中にアドオンが初期化し、その後にコレクションやプロファイルを
読み込むからです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;復習時期のカードの取得:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;card = mw.col.sched.getCard()
if not card:
    # 現在の単語帳は復習済み&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;カードを解答する:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.col.sched.answerCard(card, ease)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;ノートを編集する (各フィールドの最後に &#34; new&#34; を追加):&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;note = card.note()
for (name, value) in note.items():
    note[name] = value + &#34; new&#34;
note.flush()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;ノートにタグ x を持つカードの ID を取得する:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;ids = mw.col.findCards(&#34;tag:x&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;指定したカード ID から質問と解答を取得する:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;for id in ids:
    card = mw.col.getCard(id)
    question = card.q()
    answer = card.a()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;データベースの変更後にスケジュールをリセットする。GUI も更新しなければならないので、
メインウィンドウ上で reset() を呼び出すことに注意してください:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.reset()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;テキストファイルをコレクションに読み込む&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.importing import TextImporter
file = u&#34;/path/to/text.txt&#34;
# 単語帳を選択
did = mw.col.decks.id(&#34;ImportDeck&#34;)
mw.col.decks.select(did)
# 単語帳にノートタイプを設定
m = mw.col.models.byName(&#34;Basic&#34;)
deck = mw.col.decks.get(did)
deck[&#39;mid&#39;] = m[&#39;id&#39;]
mw.col.decks.save(deck)
# コレクションに読み込む
ti = TextImporter(mw.col, file)
ti.initMapping()
ti.run()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ほとんど全ての GUI 処理は &#39;anki&#39; 内に関連する関数を持っています。このため、Anki が利用
できるどんな処理でも、アドオンの中で同様に呼び出すことができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;GUI の外側のコレクションにアクセスする場合は、次のようなコードを使います:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki import Collection
col = Collection(&#34;/path/to/collection.anki2&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki の外部のコレクションに何らかの修正を加えたときは、修正が済んだら col.close() を必ず呼び出さなければなりません。
これを怠ると修正点は失われます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_データベース&#34;&gt;データベース&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;anki&#39; がサポートしていない処理を実行する必要がある場合は、データベースに直接アクセスする
ことができます。Anki コレクションは、SQLite ファイル内に保存されています。詳しい情報は、
&lt;a href=&#34;http://www.sqlite.org/lang.html&#34;&gt;SQLite documentation&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki のデータベースオブジェクトは次のような関数をサポートしています:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;execute() は、挿入と更新処理を実行します。指定した引数は ? を一緒に使います。例えば:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.col.db.execute(&#34;update cards set ivl = ? where id = ?&#34;, newIvl, cardId)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;executemany() は、更新と挿入を一括処理します。大規模な更新にはこの関数の方が、
execute() で個別にデータを処理するよりも非常に高速に処理します。例えば:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;data = [[newIvl1, cardId1], [newIvl2, cardId2]]
mw.col.db.executemany(same_sql_as_above, data)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;scalar() は、単一の項目を返します:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;showInfo(&#34;card count: %d&#34; % mw.col.db.scalar(&#34;select count() from cards&#34;))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;list() は、各行の最初の列をリストで返します。次のコードの戻り値は [1, 2, 3]です:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;ids = mw.col.db.list(&#34;select id from cards limit 3&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;all() は、各行がリストの場合、行のリストを返します:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;ids_and_ivl = mw.col.db.all(&#34;select id, ivl from cards&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;execute() は、中間リストを作らずに結果の集合への処理を繰り返すのに使えます。例:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;for id, ivl in mw.col.db.execute(&#34;select id, ivl from cards limit 3&#34;):
    showInfo(&#34;card id %d has ivl %d&#34; % (id, ivl))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンが、コレクションの中のテーブルを修正することが決してないように注意してください。
このことは、Anki 将来のバージョンで変更になる場合があります。プラグイン専用のデータを保存する
必要がある時には、衝突を避けて新しいテーブルを作るか、別のファイルにデータを保存するようにして
ください。小さい設定項目は、mw.col.conf の中に保存できますが、同期の度にコピーするため、
大規模なデータを保存しないでください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_フック&#34;&gt;フック&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フックをコードのわずかな箇所に追加して、アドオンの作成がもっと簡単になるようにしました。
フックは 2 種類あります。&#39;hooks&#39; は引数を取り、戻り値はありませんが、&#39;filters&#39; 引数を取り、
(おそらく何らかの修正を加えて) 値を返します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;hook&#39; の簡単な例は、無駄なカード (leech) の処理の中に見つかります。スケジューラー
(anki/sched.py) が、無駄なカードを見つけると、&#39;hook&#39; を呼び出します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;runHook(&#34;leech&#34;, card)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;無駄なカードが現れた時に、特定の処理を行いたい場合、例えばそのカードを &#34;Difficult&#34;
という名前の単語帳に移動する場合、次のようなコードで実現できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import addHook
from aqt.mw import mw

def onLeech(card):
    # スケジューラーが修正する際には、 .flush() を使わずに修正できます。
    card.did = mw.col.decks.id(&#34;Difficult&#34;)
    # カードがフィルター単語帳の中にある場合は、復習時期を元に戻して
    # 取得元の単語帳に戻さなければなりません
    card.odid = 0
    if card.odue:
        card.due = card.odue
        card.odue = 0

addHook(&#34;leech&#34;, onLeech)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;aqt/editor.py の中に &#39;filter&#39; の例があります。エディターは、入力欄からフォーカスが外れる
と &#34;editFocusLost&#34; filter を呼び出します。そして、アドオンはノートに変更を加えます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;if runFilter(
    &#34;editFocusLost&#34;, False, self.note, self.currentField):
    # ノートを更新して、スケジュールを再度読み込む
    def onUpdate():
        self.loadNote()
        self.checkValid()
    self.mw.progress.timer(100, onUpdate, False)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;filter は 3 つの引数を指定できます。修正フラグ、ノート、現在のフィールドです。
filter が変更を加えない場合は、修正フラグは受け取った値と同じ値を返します。
変更を加えた場合は、True を返します。このようにして、どんなアドオンでも変更を加えると
ユーザーインターフェイスは、ノートを読み込み直して、更新内容を表示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Japanese Support アドオンは、このフックを使って別のフィールドからフィールドを自動的に生成します。
単純化したものを次に示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;def onFocusLost(flag, n, fidx):
    from aqt import mw
    # japanese model か?
    if &#34;japanese&#34; not in n.model()[&#39;name&#39;].lower():
        return flag
    # src フィールドと dst フィールドがあるか?
    for c, name in enumerate(mw.col.models.fieldNames(n.model())):
        for f in srcFields:
            if name == f:
                src = f
                srcIdx = c
        for f in dstFields:
            if name == f:
                dst = f
    if not src or not dst:
        return flag
    # dst フィールドは入力済みか?
    if n[dst]:
        return flag
    # イベントは src フィールドで発生したか?
    if fidx != srcIdx:
        return flag
    # ソーステキストを取得
    srcTxt = mw.col.media.strip(n[src])
    if not srcTxt:
        return flag
    # 欄を更新
    try:
        n[dst] = mecab.reading(srcTxt)
    except Exception, e:
        mecab = None
        raise
    return True

addHook(&#39;editFocusLost&#39;, onFocusLost)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;filter の第一引数は、必ず返される引数です。このフォーカスを失った時の filter の中では、
引数はフラグですが、別のオブジェクトになる場合もあります。例えば、anki/collection.py
の中では、_renderQA() は、カードの表面と裏面用に生成した HTML を収容する &#34;mungeQA&#34; filter
を呼び出します。latex.py は、この filter を LaTeX タグの中のテキストを画像に変換する
のに使っています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_モンキーパッチとメソッドの隠蔽&#34;&gt;モンキーパッチとメソッドの隠蔽&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フックを持っていない関数を修正したい場合には、カスタム版の関数で上書きすることが可能です。
このことを、「モンキーパッチ」を呼ぶことがあります&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;aqt/editor.py には、setupButtons() という関数があり、エディターの中にある太字ボタン、
斜字体ボタンのようなボタンを生成します。自分のアドオンに違ったボタンを追加することを考えて
みましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;一番簡単な方法は、Anki のソースコードからその関数をコピーペーストして、自分のテキストを
ボタンに追加します。そして、元の関数を上書きします。次の通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.editor import Editor

def mySetupButtons(self):
    &amp;lt;オリジナルからコピーペーストしたコード&amp;gt;
    &amp;lt;カスタムアドオンのコード&amp;gt;

Editor.setupButtons = mySetupButtons&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この方法は、将来の Anki のバージョンで元のコードが更新されるような場合に、自分のアドオンも
更新する必要になる問題をはらんでいます。もっと良い方法は、オリジナルの関数を保存しておいて
自分のカスタムバージョンの中で呼び出すことです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.editor import Editor

def mySetupButtons(self):
    origSetupButtons(self)
    &amp;lt;カスタムアドオンのコード&amp;gt;

origSetupButtons = Editor.setupButtons
Editor.setupButtons = mySetupButtons&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;これはよく行われる処理なので、Anki では wrap() という関数を提供して、もう少し使いやすく
しています。実際の例をご紹介します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import wrap
from aqt.editor import Editor
from aqt.utils import showInfo

def buttonPressed(self):
    showInfo(&#34;pressed &#34; + `self`)

def mySetupButtons(self):
    # - size=False は、小さいボタンは使わない
    # - lambda は、予め設定されているメソッドの代わりに関数の中で
    #    エディタインスタンスをコールバックに渡す時に必要
    self._addButton(&#34;mybutton&#34;, lambda s=self: buttonPressed(self),
                    text=&#34;PressMe&#34;, size=False)

Editor.setupButtons = wrap(Editor.setupButtons, mySetupButtons)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;既定では、wrap() は元のコードの後にカスタムコードを実行します。第3引数 &#34;before&#34; を渡すと
これを逆転できます。元のバージョンの前と後の両方で実行する必要がある場合は、次のようにします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import wrap
from aqt.editor import Editor

def mySetupButtons(self, _old):
    &amp;lt;オリジナルの前で実行するコード&amp;gt;
    ret = _old(self)
    &amp;lt;オリジナルの後で実行するコード&amp;gt;
    return ret

Editor.setupButtons = wrap(Editor.setupButtons, mySetupButtons, &#34;around&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;関数の前後でコードを実行するのではなく、関数の中を修正する必要がある場合には、元のコードの
中の対象とする関数にフックを追加するのが良い方法かも知れません。このような場合には、
追加するフックについての質問をフォーラムに投稿してください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_qt&#34;&gt;Qt&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;上記にあるとおり、&lt;a href=&#34;http://doc.qt.io/qt-4.8/index.html&#34;&gt;Qt documentation&lt;/a&gt; が
色々な GUI を表示する方法を学ぶのに非常に貴重な文書です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;一つ覚えておいてほしいことは、Python ではオブジェクトはガベージコレクションされます。
次のように記述するとどうなるでしょうか。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;def myfunc():
    widget = QWidget()
    widget.show()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;すると、この関数を終了するとすぐにウェジットは消えてしまいます。これを避けるには、
トップレベルのウェジットに既存のオブジェクトを割り当てます。次の通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;def myfunc():
    mw.myWidget = widget = QWidget()
    widget.show()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_標準モジュール&#34;&gt;標準モジュール&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は、このプログラムの実行に必要な標準モジュールだけを含めて提供しています。Python
の完全な複製を含んではいません。このために、Anki が含んでいない標準モジュールを使う必要が
ある場合には、自分のアドオンに同梱する必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_デバッグ&#34;&gt;デバッグ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;自分のコードから例外が発生した時には、Anki の標準例外ハンドラー (標準エラー出力に書き出さ
れるものは何でも) が補足します。デバッグ目的のために、情報を出力する必要がある場合は、
aqt.utils.showInfo を使うか、sys.stderr.write(&#34;text\n&#34;) で標準エラー出力に書き出す
必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki には、REPL が含まれています。プログラムの中から Ctrl+: または Command+: を押すと
ウィンドウが立ち上がります。上の欄に式や文を入力し、ctrl+return/command+return を押すと
評価します。セッション例を次に挙げます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; mw
&amp;lt;no output&amp;gt;

&amp;gt;&amp;gt;&amp;gt; print mw
&amp;lt;aqt.main.AnkiQt object at 0x10c0ddc20&amp;gt;

&amp;gt;&amp;gt;&amp;gt; invalidName
Traceback (most recent call last):
  File &#34;/Users/dae/Lib/anki/qt/aqt/main.py&#34;, line 933, in onDebugRet
    exec text
  File &#34;&amp;lt;string&amp;gt;&#34;, line 1, in &amp;lt;module&amp;gt;
NameError: name &#39;invalidName&#39; is not defined

&amp;gt;&amp;gt;&amp;gt; a = [a for a in dir(mw.form) if a.startswith(&#34;action&#34;)]
... print a
... print
... pp(a)
[&#39;actionAbout&#39;, &#39;actionCheckMediaDatabase&#39;, ...]

[&#39;actionAbout&#39;,
 &#39;actionCheckMediaDatabase&#39;,
 &#39;actionDocumentation&#39;,
 &#39;actionDonate&#39;,
 ...]

&amp;gt;&amp;gt;&amp;gt; pp(mw.reviewer.card)
&amp;lt;anki.cards.Card object at 0x112181150&amp;gt;

&amp;gt;&amp;gt;&amp;gt; pp(card()) # mw.reviewer.card.__dict__ へのショートカット
{&#39;_note&#39;: &amp;lt;anki.notes.Note object at 0x11221da90&amp;gt;,
 &#39;_qa&#39;: [...]
 &#39;col&#39;: &amp;lt;anki.collection._Collection object at 0x1122415d0&amp;gt;,
 &#39;data&#39;: u&#39;&#39;,
 &#39;did&#39;: 1,
 &#39;due&#39;: -1,
 &#39;factor&#39;: 2350,
 &#39;flags&#39;: 0,
 &#39;id&#39;: 1307820012852L,
 [...]
}

&amp;gt;&amp;gt;&amp;gt; pp(bcard()) # ブラウザで選択したカードへのショートカット
&amp;lt;as above&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;何が評価されたか知るためには、式を明示的に出力する必要があることに注意してください。Anki では
pp() (pretty print) がスコープの中でオブジェクトの詳細を素早くダンプすることが簡単に
できるようになっています。ショートカット ctrl+shift+return は上の欄中の現在のテキストを
pp() で囲んで実行し結果を表示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Linux を使っているかソースコードから Anki を実行している場合は、自分のスクリプトを pdb を
使ってデバッグすることも可能です。次の行を自分のコードのどこかに置けば、Anki がその場所に
達するとターミナルにデバッガーが立ち上がります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.qt import debug; debug()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;別の方法としては、export DEBUG=1 と自分のシェルで実行すれば、補足していない例外個所で
デバッガーが立ち上がります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_もっと詳しく学びたい場合には&#34;&gt;もっと詳しく学びたい場合には&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;anki と aqt の両方が &lt;a href=&#34;http://github.com/dae/&#34; class=&#34;bare&#34;&gt;http://github.com/dae/&lt;/a&gt; で入手できます。コレクション
オブジェクトは、anki の collection.py の中で定義されています。他に調べる価値のある
ファイルは、cards.py、notes.py、sched.py、models.py や decks.py です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;aqt のソースコード見ることも、特定の処理のための anki の呼び出し方や GUI の詳細
を理解するのに役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;多くの GUI は、designer ファイルの中で定義されてます。Qt Designer というプログラムを
使えば .ui ファイルを開いて、GUI をブラウズすることが簡単にできます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;最後になりますが、他のアドオンが何かを実現している方法を見ることも、非常に役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_anki_1_2_プラグインからの移植&#34;&gt;Anki 1.2 プラグインからの移植&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意すべき主な変更点:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;テーブルの変更: facts&amp;#8594;notes、reviewHistory&amp;#8594;revlog&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;フィールドは、現在 notes テーブルに &#39;flds&#39; という単体のテキストフィールドに保存している。
各フィールドは \x1f で区切られている。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;cardTags テーブルを廃止しました。以前と同様の方法で検索するには
col.findCards(&#34;tag:x note:y card:z&#34;) をお使いください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;スケジュールのコードは全て sched.py にあります。単語帳のコードは collection.py です。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;notes テーブルを一括更新する場合は、findReplace() を使わないでください。
必ず col.updateFieldCache() を呼び出してください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;Q/A キャッシュを廃止しました。このため質問か解答を生成していないカードの中を
テキスト検索することはできません。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;変更の前にコレクションを保存するには、古いアンドゥ (元に戻す) システムの代わりに
mw.checkpoint(&#34;Undo Name&#34;) を呼び出してください。ユーザーが操作をやり直す場合、
保存済みの状態に戻ります。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;変更の同期を確実にするには、ノートやカードをデータベース内で修正した場合に、mod の更新と
usn が col.usn() に設定を必ず行ってください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;同様に、モデルや単語帳を修正した場合は、適切なマネージャで必ず save() を呼んでください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;タイマーを設定する場合は、mw.progress.timer() を使って、データベース処理の最中に
タイマーが起動することが決して起らないようにしてください。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;stats テーブルを廃止しました。同期中のマージはできなくなりました。統計は revlog
テーブルから引き出す必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_アドオンの共有&#34;&gt;アドオンの共有&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;単純な一つのファイルからなるアドオンは、その .py をアップロードできます。複数のファイルの
アドオンは、Python パッケージとして動作するようにサブホルダーを作って、パッケージを読み込む
小さな .py ファイルを作ってください。Japanese support アドオンを使って説明しますと
次のような構造になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;japanese/file1.py
japanese/file2.py
japanese/__init__.py # 空も可能。このフォルダーがパッケージであることを示す
japanese/&amp;lt;バイナリーのサポートファイル&amp;gt;
jp.py&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;複数ファイルのアドオンをアップロードするには、フォルダーとローダー .py ファイルを zip
ファイルにして、その zip ファイルをアップロードしてください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;https://ankiweb.net/shared/addons/&#34; class=&#34;bare&#34;&gt;https://ankiweb.net/shared/addons/&lt;/a&gt; にアドオンをアップロードしてください。&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_日本語版訳注&#34;&gt;日本語版訳注&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2 の変更点を知るには、&lt;a href=&#34;http://rs.luminousspice.com/changeinanki2/&#34;&gt;Anki 2の変更点&lt;/a&gt; が役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;更に、アプリケーションの個々の機能や処理を詳しく理解するには &lt;a href=&#34;http://ankisrs.net/docs/manual.html&#34;&gt;Anki User Manual&lt;/a&gt; をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオン開発の簡単なチュートリアルとして &lt;a href=&#34;http://rs.luminousspice.com/how_to_create_anki_add-ons/&#34;&gt;フックを使った Anki アドオンのつくり方&lt;/a&gt;を用意しました。この記事を補足して独自フックの追加してアドオンを作成する方法や、作成したアドオンを AnkiWeb のアドオン一覧へ登録する方法について説明しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_日本語版更新履歴&#34;&gt;日本語版更新履歴&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2012/09/16 Anki 2 Release Candidate 4準拠 (2012/09/08版)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013/02/03 Anki 2.0.5準拠 (2012/12/20版)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013/05/07 Anki 2.0.8準拠 (2013/05/07版)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2013/06/07 Anki 2.0.8準拠 (2013/05/13版)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2014/02/15 Anki 2.0.22準拠 (2014/02/14版)&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2016/05/01 Anki 2.0.33準拠 (2016/03/04版)&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    </item>
    
  </channel>
</rss>
