<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Anki on the Right Stuff</title>
    <link>http://rs.luminousspice.com/tags/anki/</link>
    <description>Anki | the Right Stuff</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>ja</language>
    <lastBuildDate>Sat, 09 Jan 2016 11:20:37 +0900</lastBuildDate>
    <atom:link href="https://pubsubhubbub.superfeedr.com" rel="hub"/>
    <atom:link href="https://pubsubhubbub.appspot.com/" rel="hub"/>
    <atom:link href="/tags/anki/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Anki 2.1.x アドオンの作成 日本語訳</title>
      <link>http://rs.luminousspice.com/ankiaddons21/</link>
      <pubDate>Sun, 27 Aug 2017 11:48:38 +0900</pubDate>
      <guid>http://rs.luminousspice.com/ankiaddons21/</guid>
      <description>Writing Anki 2.1.x Add-ons  の日本語訳。簡単なサンプルを使ったアドオン作成の概要、データベースアクセスの方法、フックを使った既存コードのカスタマイズ、デバッグ、v 2.0 からの移植、アドオンの共有方法について説明しています。</description>
      <content>&lt;div id=&#34;preamble&#34;&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Writing Anki 2.0.x Add-ons  の日本語訳。簡単なサンプルを使ったアドオン作成の概要、データベースアクセスの方法、フックを使った既存コードのカスタマイズ、デバッグ、v 2.0 からの移植、アドオンの共有方法について説明しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_日本語版をご覧いただく前に&#34;&gt;日本語版をご覧いただく前に&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この文書は、&lt;a href=&#34;http://ankisrs.net/docs/addons21.html&#34;&gt;Writing Anki 2.1.x Add-ons&lt;/a&gt; 2017-09-10 版の日本語訳です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.1.x は 2017 年 9 月 10 日現在、最新バージョンは 2.1 Beta 16 です。より最新で正確な情報をご覧になりたい方は、原本をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;また、&lt;a href=&#34;http://rs.luminousspice.com/anki2addons&#34;&gt;Anki 2.0.x 用の文書の日本語訳&lt;/a&gt;もご覧頂けます。&lt;/p&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_anki_2_1_x_アドオンの作成&#34;&gt;Anki 2.1.x アドオンの作成&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_他のバージョン&#34;&gt;他のバージョン&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この文書では、まだリリースしていませんが Anki 2.1.x 用のアドオンの作成について扱います。Anki 2.0.x 用については &lt;a href=&#34;https://apps.ankiweb.net/docs/addons.html&#34; class=&#34;bare&#34;&gt;https://apps.ankiweb.net/docs/addons.html&lt;/a&gt; をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_他の言語&#34;&gt;他の言語&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;英語 (原文): &lt;a href=&#34;https://apps.ankiweb.net/docs/addons21.html&#34; class=&#34;bare&#34;&gt;https://apps.ankiweb.net/docs/addons21.html&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ロシア語: &lt;a href=&#34;http://finpapa.ucoz.ru/ankitest-addons.html#addons21&#34; class=&#34;bare&#34;&gt;http://finpapa.ucoz.ru/ankitest-addons.html#addons21&lt;/a&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_概要&#34;&gt;概要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は、ユーザーフレンドリーなプログラミング言語 Python で作成しています。
Python についてあまり詳しくない方は、この文書の先を読む前に
&lt;a href=&#34;http://docs.python.org/tutorial/&#34;&gt;Python tutorial&lt;/a&gt; をお読みください。
(訳注: &lt;a href=&#34;https://docs.python.org/ja/3/tutorial/&#34;&gt;Python チュートリアル
日本語版&lt;/a&gt;)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Python は動的言語なため、Anki ではアドオンが極めて強力に機能します。アドオンは Anki の処理
を拡張するだけでなく、Anki の任意の側面に変更を加えることができます。例えば、スケジュール
設定の処理を変更したり、ユーザーインターフェイスを修正したりすることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;プラグインの開発には、特別な開発環境は必要ありません。テキストエディタがあれば十分です。
Windows や Mac をお使いの方は、このサイトで提供しているパッケージ版の Anki をお使いください。これらの
プラットフォーム上でゼロから Anki を構築するための説明が入手できないためです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;メモ帳のような単純なテキストエディタでプラグインを作成できますが、シンタックスハイライト
機能 (コードの色分け) を持ったエディタを探してみると、作業がより簡単になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki を構成する2つの要素&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;anki&#39; には、「背後」で動作する全てのコードが含まれています。コレクションを開いたり、
カードを取得し、回答する処理などです。これは、Anki の GUI が使用していますが、GUI を使わず
に Anki 単語帳にアクセスするコマンドラインプログラムに含めることもできます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;aqt&#39; には、Anki のユーザーインターフェイスの部分が含まれています。Anki のユーザー
インターフェイスは、PyQt 上に構築されています。PyQt とは、クロスプラットフォーム GUI
ツールキット Qt に対する Python バインディングです。PyQt は、Qt の API に密接に動作
します。Qt documentation は、特定の GUI
コンポーネントの使い方を調べたい時に、非常に役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.1.x は &lt;a href=&#34;http://doc.qt.io/qt-5/index.html&#34;&gt;Qt 5.9&lt;/a&gt; を使用しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki が起動すると、アドオンフォルダ内のモジュールを確認し、見つけたモジュールを一つづつ実行します。アドオンを実行すると、通常は既存のコードを変更したり、新しい機能を呼び出すメニュー項目を新たに追加します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_アドオンフォルダ&#34;&gt;アドオンフォルダ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki のメインウィンドウのメニューから Tools&amp;gt;Add-ons と選ぶと、アドオンフォルダの最上位階層にアクセスできます。View Files ボタンを押すとフォルダがポップアップします。アドオンをまだ何もインストールしていない場合は、最上位のアドオンフォルダが開きます。アドオンを選択している場合は、アドオンのモジュールフォルダが開きます。これは最上位階層の一つ下の階層になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンフォルダの名前は、&#34;addons21&#34;　です。Anki 2.1 に対応しています。&#34;addons&#34; があるのは、以前 Anki 2.0.x を使っていたためです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;それぞれのアドオンは、アドオンフォルダの中の一つのフォルダを使います。Anki はそのフォルダの中にあるファイル &lt;code&gt;__init__.py&lt;/code&gt; を探します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;addons21/my_addon/__init__.py&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;もし &lt;code&gt;__init__.py&lt;/code&gt; がなければ、Anki はそのフォルダを無視します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フォルダ名を決めるときには、a-z と 0-9 の範囲の文字から選ぶことおすすめします。これによって、Python モジュールシステムによる問題を避けることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;自分でフォルダを作るときはどんな名前でも使えますが、AnkiWeb からアドオンをダウンロードするときは、Anki はそのアドオンの ID をフォルダ名に使います。例えば次の通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;addons21/48927303923/__init__.py&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki はさらにフォルダに meta.json ファイルを保存して、ダウンロードした時の元のアドオン名と、アドオンの利用許可を追跡ます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ユーザーデータをアドオンフォルダに保存できません。&lt;a href=&#34;#configuration&#34;&gt;そのようなデータは、ユーザーがアドオンをアップグレードすると、削除される&lt;/a&gt;からです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_簡単なアドオンの一例&#34;&gt;簡単なアドオンの一例&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;次に示す &lt;code&gt;my_first_addon/__init__.py&lt;/code&gt; を、自分のアドオンフォルダに追加してみてください:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;# aqt からメインウィンドウオブジェクト (mw) を読み込みます
from aqt import mw
# utils.py から &#34;show info&#34; ツールを読み込みます
from aqt.utils import showInfo
# Qt GUI ライブラリの全てを読み込みます
from aqt.qt import *

# 次のようなメニュー項目を追加してみましょう。まず最初にメニュー項目が利用可能になったら
# 呼び出す関数を作成します。

def testFunction():
    # 現在使用中のコレクションの中のカードの枚数を取得します
    # このコレクションはメインウィンドウの中に保存しています
    cardCount = mw.col.cardCount()
    # メッセージボックスを表示します
    showInfo(&#34;Card count: %d&#34; % cardCount)

# 新しいメニュー項目 &#34;test&#34; を作成します。
action = QAction(&#34;test&#34;, mw)
# この項目をクリックしたら testFunction を呼び出すように設定します。
action.triggered.connect(testFunction)
# そして、この設定をツールメニューに反映します。
mw.form.menuTools.addAction(action)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki を再起動すると、ツールメニューの中に &#39;test&#39; 項目が追加されていることに気づくでしょう。
この項目を選択して実行するとカード枚数を表示するダイアログが現れます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;プラグインの入力中に間違いがあった場合には、Anki は起動時にエラーメッセージを表示して
どこに問題があるか指摘します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_コレクション&#34;&gt;コレクション&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;コレクションファイル上の全ての操作は、mw.col を通じてアクセスします。基本的な例で
何ができるがご紹介します。注意してほしいのは、上の例のように testFunction() の中で行ってください。
アドオンの中で直接実行することはできません。それは、Anki を起動中にアドオンが初期化し、その後にコレクションやプロファイルを
読み込むからです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;復習時期のカードの取得:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;card = mw.col.sched.getCard()
if not card:
    # 現在の単語帳は復習済み&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;カードを解答する:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.col.sched.answerCard(card, ease)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;ノートを編集する (各フィールドの最後に &#34; new&#34; を追加):&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;note = card.note()
for (name, value) in note.items():
    note[name] = value + &#34; new&#34;
note.flush()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;ノートにタグ x を持つカードの ID を取得する:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;ids = mw.col.findCards(&#34;tag:x&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;指定したカード ID から質問と解答を取得する:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;for id in ids:
    card = mw.col.getCard(id)
    question = card.q()
    answer = card.a()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;データベースの変更後にスケジュールをリセットする。GUI も更新しなければならないので、
メインウィンドウ上で reset() を呼び出すことに注意してください:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.reset()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;テキストファイルをコレクションに読み込む&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.importing import TextImporter
file = u&#34;/path/to/text.txt&#34;
# 単語帳を選択
did = mw.col.decks.id(&#34;ImportDeck&#34;)
mw.col.decks.select(did)
# 単語帳にノートタイプを設定
m = mw.col.models.byName(&#34;Basic&#34;)
deck = mw.col.decks.get(did)
deck[&#39;mid&#39;] = m[&#39;id&#39;]
mw.col.decks.save(deck)
# コレクションに読み込む
ti = TextImporter(mw.col, file)
ti.initMapping()
ti.run()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ほとんど全ての GUI 処理は &#39;anki&#39; 内に関連する関数を持っています。このため、Anki が利用
できるどんな処理でも、アドオンの中で同様に呼び出すことができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;GUI の外側のコレクションにアクセスする場合は、次のようなコードを使います:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki import Collection
col = Collection(&#34;/path/to/collection.anki2&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki の外部のコレクションに何らかの修正を加えたときは、修正が済んだら col.close() を必ず呼び出さなければなりません。
これを怠ると修正点は失われます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_データベース&#34;&gt;データベース&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;anki&#39; がサポートしていない処理を実行する必要がある場合は、データベースに直接アクセスする
ことができます。Anki コレクションは、SQLite ファイル内に保存されています。詳しい情報は、
&lt;a href=&#34;http://www.sqlite.org/lang.html&#34;&gt;SQLite documentation&lt;/a&gt;をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki のデータベースオブジェクトは次のような関数をサポートしています:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;execute() は、挿入と更新処理を実行します。指定した引数は ? を一緒に使います。例えば:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.col.db.execute(&#34;update cards set ivl = ? where id = ?&#34;, newIvl, cardId)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;executemany() は、更新と挿入を一括処理します。大規模な更新にはこの関数の方が、
execute() で個別にデータを処理するよりも非常に高速に処理します。例えば:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;data = [[newIvl1, cardId1], [newIvl2, cardId2]]
mw.col.db.executemany(same_sql_as_above, data)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;scalar() は、単一の項目を返します:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;showInfo(&#34;card count: %d&#34; % mw.col.db.scalar(&#34;select count() from cards&#34;))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;list() は、各行の最初の列をリストで返します。次のコードの戻り値は [1, 2, 3]です:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;ids = mw.col.db.list(&#34;select id from cards limit 3&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;all() は、各行がリストの場合、行のリストを返します:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;ids_and_ivl = mw.col.db.all(&#34;select id, ivl from cards&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;strong&gt;execute() は、中間リストを作らずに結果の集合への処理を繰り返すのに使えます。例:&lt;/strong&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;for id, ivl in mw.col.db.execute(&#34;select id, ivl from cards limit 3&#34;):
    showInfo(&#34;card id %d has ivl %d&#34; % (id, ivl))&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンは、既存のテーブルのスキーマを決して変更してはいけません。そうすると将来のバージョンの Anki を破壊するかもしれないからです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオン独自のデータが必要な場合は、Anki の &lt;a href=&#34;#configuration&#34;&gt;設定&lt;/a&gt; サポートの使用を考慮してください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;デバイス間でデータを同期する必要する場合は、小さな設定項目を mw.col.conf に保存できます。そこに大量なデータは保存しないでください。同期のたびに送ることになるからです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_フック&#34;&gt;フック&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フックをコードのわずかな箇所に追加して、アドオンの作成がもっと簡単になるようにしました。
フックは 2 種類あります。&#39;hooks&#39; は引数を取り、戻り値はありませんが、&#39;filters&#39; 引数を取り、
(おそらく何らかの修正を加えて) 値を返します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&#39;hook&#39; の簡単な例は、無駄なカード (leech) の処理の中に見つかります。スケジューラー
(anki/sched.py) が、無駄なカードを見つけると、&#39;hook&#39; を呼び出します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;runHook(&#34;leech&#34;, card)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;無駄なカードが現れた時に、特定の処理を行いたい場合、例えばそのカードを &#34;Difficult&#34;
という名前の単語帳に移動する場合、次のようなコードで実現できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import addHook
from aqt import mw

def onLeech(card):
    # スケジューラーが修正する際には、 .flush() を使わずに修正できます。
    card.did = mw.col.decks.id(&#34;Difficult&#34;)
    # カードがフィルター単語帳の中にある場合は、復習時期を元に戻して取得元の単語帳に
    # 戻さなければなりません
    card.odid = 0
    if card.odue:
        card.due = card.odue
        card.odue = 0

addHook(&#34;leech&#34;, onLeech)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;aqt/editor.py の中に &#39;filter&#39; の例があります。エディターは、入力欄からフォーカスが外れる
と &#34;editFocusLost&#34; filter を呼び出します。そして、アドオンはノートに変更を加えます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;if runFilter(
    &#34;editFocusLost&#34;, False, self.note, self.currentField):
    # ノートを更新して、スケジュールを再度読み込む
    def onUpdate():
        self.loadNote()
        self.checkValid()
    self.mw.progress.timer(100, onUpdate, False)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このサンプルでは、それぞれの filter は 3 つの引数を受け取ります。修正フラグ、ノート、現在のフィールドです。
filter が変更を加えない場合は、修正フラグは受け取った値と同じ値を返します。
変更を加えた場合は、True を返します。このようにして、どんなアドオンでも変更を加えると
ユーザーインターフェイスは、ノートを読み込み直して、更新内容を表示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Japanese Support アドオンは、このフックを使って別のフィールドからフィールドを自動的に生成します。
単純化したものを次に示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;def onFocusLost(flag, n, fidx):
    from aqt import mw
    # japanese model か?
    if &#34;japanese&#34; not in n.model()[&#39;name&#39;].lower():
        return flag
    # src フィールドと dst フィールドがあるか?
    for c, name in enumerate(mw.col.models.fieldNames(n.model())):
        for f in srcFields:
            if name == f:
                src = f
                srcIdx = c
        for f in dstFields:
            if name == f:
                dst = f
    if not src or not dst:
        return flag
    # dst フィールドは入力済みか?
    if n[dst]:
        return flag
    # イベントは src フィールドで発生したか?
    if fidx != srcIdx:
        return flag
    # ソーステキストを取得
    srcTxt = mw.col.media.strip(n[src])
    if not srcTxt:
        return flag
    # 欄を更新
    try:
        n[dst] = mecab.reading(srcTxt)
    except Exception, e:
        mecab = None
        raise
    return True

addHook(&#39;editFocusLost&#39;, onFocusLost)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;filter の第一引数は、必ず返される引数です。このフォーカスを失った時の filter の中では、
引数はフラグですが、別のオブジェクトになる場合もあります。例えば、anki/collection.py
の中では、_renderQA() は、カードの表面と裏面用に生成した HTML を収容する &#34;mungeQA&#34; filter
を呼び出します。latex.py は、この filter を LaTeX タグの中のテキストを画像に変換する
のに使っています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.1 では、エディタにボタンを追加するフックを追加しました。次のように使います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.utils import showInfo
from anki.hooks import addHook

# cross out the currently selected text
def onStrike(editor):
    editor.web.eval(&#34;wrap(&#39;&amp;lt;del&amp;gt;&#39;, &#39;&amp;lt;/del&amp;gt;&#39;);&#34;)

def addMyButton(buttons, editor):
    editor._links[&#39;strike&#39;] = onStrike
    return buttons + [editor._addButton(
        &#34;iconname&#34;, # &#34;/full/path/to/icon.png&#34;,
        &#34;strike&#34;, # link name
        &#34;tooltip&#34;)]

addHook(&#34;setupEditorButtons&#34;, addMyButton)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_モンキーパッチとメソッドの隠蔽&#34;&gt;モンキーパッチとメソッドの隠蔽&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フックを持っていない関数を修正したい場合には、カスタム版の関数で上書きすることが可能です。
このことを、「モンキーパッチ」を呼ぶことがあります&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;aqt/editor.py には、setupButtons() という関数があり、エディターの中にある太字ボタン、
斜字体ボタンのようなボタンを生成します。自分のアドオンに違ったボタンを追加することを考えて
みましょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;警告: Anki 2.1 は、setupButtons() をもう使用していません。このコードは、モンキーパッチがどのように動作しているか、理解するのに役立ちますが、エディタにボタンと追加するには、前の項目で説明した setupEditorButtons フックを見てください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;一番簡単な方法は、Anki のソースコードからその関数をコピーペーストして、自分のテキストを
ボタンに追加します。そして、元の関数を上書きします。次の通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.editor import Editor

def mySetupButtons(self):
    &amp;lt;オリジナルからコピーペーストしたコード&amp;gt;
    &amp;lt;カスタムアドオンのコード&amp;gt;

Editor.setupButtons = mySetupButtons&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この方法は、将来の Anki のバージョンで元のコードが更新されるような場合に、自分のアドオンも
更新する必要になる問題をはらんでいます。もっと良い方法は、オリジナルの関数を保存しておいて
自分のカスタムバージョンの中で呼び出すことです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.editor import Editor

def mySetupButtons(self):
    origSetupButtons(self)
    &amp;lt;カスタムアドオンのコード&amp;gt;

origSetupButtons = Editor.setupButtons
Editor.setupButtons = mySetupButtons&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;これはよく行われる処理なので、Anki では wrap() という関数を提供して、もう少し使いやすく
しています。実際の例をご紹介します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import wrap
from aqt.editor import Editor
from aqt.utils import showInfo

def buttonPressed(self):
    showInfo(&#34;pressed &#34; + `self`)

def mySetupButtons(self):
    # - size=False は、小さいボタンは使わない
    # - lambda は、予め設定されているメソッドの代わりに関数の中で
    #    エディタインスタンスをコールバックに渡す時に必要
    self._addButton(&#34;mybutton&#34;, lambda s=self: buttonPressed(self),
                    text=&#34;PressMe&#34;, size=False)

Editor.setupButtons = wrap(Editor.setupButtons, mySetupButtons)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;既定では、wrap() は元のコードの後にカスタムコードを実行します。第3引数 &#34;before&#34; を渡すと
これを逆転できます。元のバージョンの前と後の両方で実行する必要がある場合は、次のようにします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import wrap
from aqt.editor import Editor

def mySetupButtons(self, _old):
    &amp;lt;オリジナルの前で実行するコード&amp;gt;
    ret = _old(self)
    &amp;lt;オリジナルの後で実行するコード&amp;gt;
    return ret

Editor.setupButtons = wrap(Editor.setupButtons, mySetupButtons, &#34;around&#34;)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;関数の前後でコードを実行するのではなく、関数の中を修正する必要がある場合には、元のコードの
中の対象とする関数にフックを追加するのが良い方法かも知れません。このような場合には、
追加するフックについての質問をサポートサイトに投稿してください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_qt&#34;&gt;Qt&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;概要で話したとおり、Qt documentation は 色々な GUI ウィジェットを表示する方法を学ぶのに非常に貴重な文書です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;一つ覚えておいてほしいことは、Python ではオブジェクトはガベージコレクションされます。
次のように記述するとどうなるでしょうか。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;def myfunc():
    widget = QWidget()
    widget.show()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;すると、この関数を終了するとすぐにウェジットは消えてしまいます。これを避けるには、
トップレベルのウェジットに既存のオブジェクトを割り当てます。次の通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;def myfunc():
    mw.myWidget = widget = QWidget()
    widget.show()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Qt オブジェクトを作って、既存のオブジェクトを親とするときには、このことはあまり必要としません。それは、親オブジェクトが新規オブジェクトを参照し続けるからです。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_標準モジュール&#34;&gt;標準モジュール&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は、このプログラムの実行に必要な標準モジュールだけを含めて提供しています。Python
の完全な複製を含んではいません。このために、Anki が含んでいない標準モジュールを使う必要が
ある場合には、自分のアドオンに同梱する必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この場合、pure Python モジュールは使えますが、numpy のような C 拡張を必要とするモジュールを同梱しても動作しません。その理由は、そのモジュールが Anki をパッケージしたアーキテクチャと一致しないためです。もし込み入ったことをするのであれば、代わりにユーザーに Python のスタンドアロンファイルをインストールしてもらう必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;configuration&#34;&gt;設定&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;JSON dictionary で設定を書いた config.json ファイルを入れると、ユーザーは Anki  のアドオンマネージャから編集できるようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;簡単な例として、config.json に次のように記述します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;{&#34;myvar&#34;: 5}&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;config.md は次のように記述します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;この文書はこのアドオンの設定用で、*markdown* フォーマットで書いています。&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンのコードには次のように記述します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt import mw
config = mw.addonManager.getConfig(__name__)
print(&#34;var is&#34;, config[&#39;myvar&#39;])&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンを更新する時には、config.json を変更することができます。既存の設定と新規追加のキーを統合します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;config.json の中の既存のキーの値を変更する場合は、設定をカスタマイズしたユーザーが、&#34;restore defaults&#34; ボタンを押さない限り、古い値を使い続けることになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;設定をプログラムで変更する必要がある場合は、次のように変更を保存します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.addonManager.writeConfig(__name__, config)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意: config.json が存在しない場合は、getConfig() は None を返します。たとえ、writeConfig() を呼んでいたとしてもです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;独自の GUI に管理オプションを持っているアドオンは、config ボタンを押した時にその GUI を表示できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;mw.addonManager.setConfigAction(__name__, myOptionsFunc)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;キー名の最初にアンダースコアを使うのを避けてください。Anki が将来利用するために予約しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;userfiles&#34;&gt;ユーザーファイル&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンの設定に簡単なキーと値の組み合わせ以外のデータが必要な時は、&#34;user_files&#34; という名前の特別なフォルダをアドオンフォルダのルートに置いて使うことができます。このフォルダに置いたファイルはどれも、アドオンの更新時に保護します。アドオンフォルダのこれ以外のファイルは全て更新時に削除します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ユーザー用の &#34;user_files&#34; フォルダを必ず確実に作るには、アドオンを zip ファイルにする前に README.txt や 同じようなファイルをその中に置くことで可能です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki がアドオンを更新する時は、zip ファイルの中で &#34;user_files&#34; にすでに存在するファイルはどれも無視します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;reviewjs&#34;&gt;質問解答画面での JavaScript&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;(2.1.0beta16 で導入予定)&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は、復習画面やプレビューダイアログ、カードレイアウト画面に質問や解答を表示する前に HTML を変更するフックを提供します。 このフックはカードに JavaScript を追加するのに役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;例:&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import addHook
def prepare(html, card, context):
    return html + &#34;&#34;&#34;
&amp;lt;script&amp;gt;
document.body.style.background = &#34;blue&#34;;
&amp;lt;/script&amp;gt;&#34;&#34;&#34;
addHook(&#39;prepareQA&#39;, prepare)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このフックは三つの引数を取ります。質問または解答の HTML、現在のカードオブジェクト (これによって、例えば特定のノートタイプにアドオンを限定することができます)、フックを実行するコンテキストを示す文字列です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;変更した HTML を必ず戻すようにしてください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;コンテキストは次の中から一つ選びます。&#34;reviewQuestion&#34;, &#34;reviewAnswer&#34;, &#34;clayoutQuestion&#34;, &#34;clayoutAnswer&#34;, &#34;previewQuestion&#34;, &#34;previewAnswer&#34;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注意: カードレイアウト面での解答のプレビューや、&#34;show both sides (両面表示)&#34; を設定したプレビュー画面は、&#34;Answer&#34; コンテキストだけ使えます。これは カードの裏面に追加した JavaScript は、表面だけに追加した JavaScript に依存すべきではないことを意味します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は新しいテキストを表示する前に、前のテキストをフェードアウトするため、JavaScript のフックは、適切なタイミングでスクロールするようにアクションを実行する必要があります。次のように行います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from anki.hooks import addHook
def prepare(html, card, context):
    return html + &#34;&#34;&#34;
&amp;lt;script&amp;gt;
onUpdateHook.push(function () {
    window.scrollTo(0, 2000);
})
&amp;lt;/script&amp;gt;&#34;&#34;&#34;
addHook(&#39;prepareQA&#39;, prepare)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;onUpdateHook は新しいカードを DOM に配置した後に発生しますが、このカードを表示する前です。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;onShownHook はこのカードがフェードインした後に発生します。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このフックは、質問や解答を表示するたびにリセットします。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_デバッグ&#34;&gt;デバッグ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;自分のコードから例外が発生した時には、Anki の標準例外ハンドラー (標準エラー出力に書き出さ
れるものは何でも) が補足します。デバッグ目的のために、情報を出力する必要がある場合は、
aqt.utils.showInfo を使うか、sys.stderr.write(&#34;text\n&#34;) で標準エラー出力に書き出す
必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki には、REPL が含まれています。プログラムの中から &lt;a href=&#34;https://apps.ankiweb.net/docs/manual.html#debug-console&#34;&gt;shortcut key&lt;/a&gt; を押すと
ウィンドウが立ち上がります。上の欄に式や文を入力し、ctrl+return/command+return を押すと
評価します。セッション例を次に挙げます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;&amp;gt;&amp;gt;&amp;gt; mw
&amp;lt;no output&amp;gt;

&amp;gt;&amp;gt;&amp;gt; print(mw)
&amp;lt;aqt.main.AnkiQt object at 0x10c0ddc20&amp;gt;

&amp;gt;&amp;gt;&amp;gt; invalidName
Traceback (most recent call last):
  File &#34;/Users/dae/Lib/anki/qt/aqt/main.py&#34;, line 933, in onDebugRet
    exec text
  File &#34;&amp;lt;string&amp;gt;&#34;, line 1, in &amp;lt;module&amp;gt;
NameError: name &#39;invalidName&#39; is not defined

&amp;gt;&amp;gt;&amp;gt; a = [a for a in dir(mw.form) if a.startswith(&#34;action&#34;)]
... print(a)
... print()
... pp(a)
[&#39;actionAbout&#39;, &#39;actionCheckMediaDatabase&#39;, ...]

[&#39;actionAbout&#39;,
 &#39;actionCheckMediaDatabase&#39;,
 &#39;actionDocumentation&#39;,
 &#39;actionDonate&#39;,
 ...]

&amp;gt;&amp;gt;&amp;gt; pp(mw.reviewer.card)
&amp;lt;anki.cards.Card object at 0x112181150&amp;gt;

&amp;gt;&amp;gt;&amp;gt; pp(card()) # mw.reviewer.card.__dict__ へのショートカット
{&#39;_note&#39;: &amp;lt;anki.notes.Note object at 0x11221da90&amp;gt;,
 &#39;_qa&#39;: [...]
 &#39;col&#39;: &amp;lt;anki.collection._Collection object at 0x1122415d0&amp;gt;,
 &#39;data&#39;: u&#39;&#39;,
 &#39;did&#39;: 1,
 &#39;due&#39;: -1,
 &#39;factor&#39;: 2350,
 &#39;flags&#39;: 0,
 &#39;id&#39;: 1307820012852L,
 [...]
}

&amp;gt;&amp;gt;&amp;gt; pp(bcard()) # ブラウザで選択したカードへのショートカット
&amp;lt;as above&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;何が評価されたか知るためには、式を明示的に出力する必要があることに注意してください。Anki では
pp() (pretty print) がスコープの中でオブジェクトの詳細を素早くダンプすることが簡単に
できるようになっています。ショートカット ctrl+shift+return は上の欄中の現在のテキストを
pp() で囲んで実行し結果を表示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Linux を使っているかソースコードから Anki を実行している場合は、自分のスクリプトを pdb を
使ってデバッグすることも可能です。次の行を自分のコードのどこかに置けば、Anki がその場所に
達するとターミナルにデバッガーが立ち上がります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.qt import debug; debug()&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;別の方法としては、export DEBUG=1 と自分のシェルで実行すれば、補足していない例外個所で
デバッガーが立ち上がります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_もっと詳しく学びたい場合には&#34;&gt;もっと詳しく学びたい場合には&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki のソースコードは &lt;a href=&#34;http://github.com/dae/&#34; class=&#34;bare&#34;&gt;http://github.com/dae/&lt;/a&gt; で入手できます。コレクション
オブジェクトは、anki の collection.py の中で定義されています。他に調べる価値のある
ファイルは、cards.py、notes.py、sched.py、models.py や decks.py です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;aqt のソースコード見ることも、特定の処理のための anki の呼び出し方や GUI の詳細
を理解するのに役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;多くの GUI は、designer ファイルの中で定義されてます。Qt Designer というプログラムを
使えば .ui ファイルを開いて、GUI をブラウズすることが簡単にできます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;最後になりますが、他のアドオンが何かを実現している方法を見ることも、非常に役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;sharing&#34;&gt;アドオンの共有&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;AnkiWeb は、アドオンモジュールを収録するには zip ファイルを要求します。フォルダ名は必要しとません。例えば、次のようなモジュールを持っているとします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;addons21/myaddon/__init__.py
addons21/myaddon/my.data&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この場合、zip ファイルの内容を次のようにしてください。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;__init__.py
my.data&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フォルダ名を含めた次のような zip ファイルは、AnkiWeb は受け付けません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;myaddon/__init__.py
myaddon/my.data&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;zip ファイルの名前は自由に付けることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Python は、実行するときに &lt;code&gt;__pycache__&lt;/code&gt; フォルダを自動的に作ります。zip を作る前に必ずこのフォルダを削除してください。AnkiWeb は、&lt;code&gt;__pycache__&lt;/code&gt; フォルダを含んだ zip ファイルを受け付けないからです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Zip ファイルを作ったら &lt;a href=&#34;https://ankiweb.net/shared/addons/&#34; class=&#34;bare&#34;&gt;https://ankiweb.net/shared/addons/&lt;/a&gt; にアップロードできます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_anki_2_0_アドオンの移植&#34;&gt;Anki 2.0 アドオンの移植&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;

&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_python_3&#34;&gt;Python 3&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.1 は Python 3.6 以降が必須です。Python 3 を自分のマシンにインストールしたら、2to3 ツールを使って、自動的に既存のスクリプトを Python 3 のコードにフォルダ単位で変換できます。 次の通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;2to3-3.6 --output-dir=aqt3 -W -n aqt
mv aqt aqt-old
mv aqt3 aqt&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ほとんどの単純なコードは自動的に変換できますが、手作業で変更の必要がある箇所が残るかもしれません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_qt5_pyqt5&#34;&gt;Qt5 / PyQt5&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;PyQt5 でシグナルとスロットをつなぐ構文が変わりました。最近の PyQt4 バージョンではこの新しい構文を同じようにサポートしていますので、Anki 2.0 と 2.1 の両方のアドオンで同じ構文を使えます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;さらに詳しい情報は次のリンクをご覧ください。
&lt;a href=&#34;http://pyqt.sourceforge.net/Docs/PyQt4/new_style_signals_slots.html&#34; class=&#34;bare&#34;&gt;http://pyqt.sourceforge.net/Docs/PyQt4/new_style_signals_slots.html&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;あるアドオン作者が次のツールがコードを自動的に変換するのに役立ったと報告してくれました。
&lt;a href=&#34;https://github.com/rferrazz/pyqt4topyqt5&#34; class=&#34;bare&#34;&gt;https://github.com/rferrazz/pyqt4topyqt5&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Qt モジュールは、&#39;PyQt4&#39; の代わりに &#39;PyQt5&#39; の中にあります。条件分岐で読み込むこともできますが、さらに簡単な方法は aqt.qt から読み込むことです。例えば次のようにします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from aqt.qt import *&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;これは、特定の Qt のバージョンを指定することなく、QDialog のような全ての Qt オブジェクトを読み込みます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_単一の_py_アドオンにも独自のフォルダが必要&#34;&gt;単一の .py アドオンにも独自のフォルダが必要&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;それぞれのアドオンは、独自のフォルダに保存することになりました。以前 &lt;code&gt;demo.py&lt;/code&gt; という名前をつけていたアドオンの場合、&lt;code&gt;demo&lt;/code&gt; というフォルダと、&lt;code&gt;__init__.py&lt;/code&gt; を一緒に作る必要あります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;2.0 との互換性を気にしないなら、名前を &lt;code&gt;demo.py&lt;/code&gt; を &lt;code&gt;demo/__init__.py&lt;/code&gt; に変更するだけで済みます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;同じファイルで 2.0 をサポートする計画の場合は、元のファイルをフォルダにコピーして (&lt;code&gt;demo.py&lt;/code&gt; &amp;#8594; &lt;code&gt;demo/demo.py&lt;/code&gt;)、さらに次のような &lt;code&gt;demo/__init__.py&lt;/code&gt; を追加して、相対的にアドオンを読み込みます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;from . import demo&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;AnkiWeb にアップロードする時にはフォルダを Zip ファイルに収める必要があります。さらに詳しい情報は &lt;a href=&#34;#sharing&#34;&gt;アドオンの共有&lt;/a&gt; をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_アップグレードでフォルダを削除&#34;&gt;アップグレードでフォルダを削除&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;アドオンを更新する時には、アドオンフォルダのすべてのファイルを削除します。例外は特別な &lt;a href=&#34;#userfiles&#34;&gt;user_files フォルダ&lt;/a&gt; だけです。アドオンが単純なキー/値の組み合わせ以外の設定データが必要な場合は、必ず関連するファイルを &#34;user_files&#34; に保存して、更新時に失われるのを避けてください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_2_0_と_2_1_を一つのコードベースでサポート&#34;&gt;2.0 と 2.1 を一つのコードベースでサポート&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ほとんどの Python 3 のコードは、Python 2 でも動作します。このため、Anki 2.0 と 2.1 の両方で動作するようにアドオンを更新することが可能です。このようにする価値があるかどうかは、必要のある変更内容によります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;scheduler に手を加えているほとんどのアドオンは、わずかな変更だけで 2.1 で動作するでしょう。reviewer、browser、editor の動作を変更するアドオンはさらに多くの作業を必要とします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;最も困難な箇所は、サポートを停止した QtWebKit から QtWebEngine への変更です。WebView を使って単純ではない操作をしている場合は、Anki 2.1 へのコードの移植は、ある程度の作業が必要になり、一つのコードベースで両方のバージョンの Anki をサポートするのは難しいと考えるかもしれません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;修正なしにアドオンが動作する場合、あるいはわずかな変更が必要な場合には、if 文をコードに追加して、同じファイルで 2.0.x と 2.1.x の両方をサポートするファイルをアップロードするのが一番簡単かもしれません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;もっと大きい変更が必要な場合は、2.0.x に対する更新を停止し、あるいは別のファイルで二つのバージョンをサポートすることを維持するのがより簡単かもしれません。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_webview_の変更点&#34;&gt;Webview の変更点&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Qt 5 は、WebKit の代わりに Chromium ベースの WebEngine を採用しました。このため、Anki の WebView には、WebEngine を現在使用しています。そのためのノートです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;外部の Chrome インスタンスを使って WebView をデバッグできるようになりました。Anki を起動する前に環境変数 QTWEBENGINE_REMOTE_DEBUGGING を 8080 に設定して、Chrome で localhost:8080 にアクセスします。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WebEngine は Python との通信に別の方法を使います。
AnkiWebView() は、WebView 用のラッパーで pycmd(str) 関数を提供します。この関数は Javascript の中で ankiwebview の onBridgeCmd(str) メドッドを呼び出します。 Anki の UI の reviewer.py や deckbrowser.py といった様々な場所で、これを使うために変更しなければなりませんでした。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;Javascript を非同期的に評価します。このため、JS の式の結果が必要な場合は ankiwebview の evalWithCallback() を使うことができます。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;この非同期の動作の結果、editor.saveNow() はコールバックが必要になりました。アドオンがブラウザ内でアクションを実行する場合、editor.saveNow() を最初に呼んでから、コールバックの中のコードの残りを実行する必要がおそらくあるでしょう。
.onSearch() を呼ぶには、.search()/.onSearchActivated() も変更する必要があります。例えば、ブラウザの .deleteNotes() をご覧ください。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;setScrollPosition() のような WebKit でサポートした様々な操作は、JavaScript で実装する必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;mw.web.triggerPageAction(QWebEnginePage.Copy) のようなページの動作も非同期で、JavaScript や遅延を使って書き直す必要があります。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;WebEngine には、WebKit のような keyPressEvent() を提供していません。このため、メニューやボタンに割り当ててないショートカットを捕捉するコードは変更しなければなりませんでした。例として、reviewer.py が setStateShortcuts() を呼んでいる方法をご覧ください。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_reviewer_の変更点&#34;&gt;Reviewer の変更点&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki は次のカードをフェードインする前に、前のカードをフェードアウトするようになりました。このため showQuestion フックが発生した時には、DOM の中の次のカードが表示できません。適切な時に Javascript を実行するのに使える新しいフックがあります。詳しくは、&lt;a href=&#34;#reviewjs&#34;&gt;こちら&lt;/a&gt; をご覧ください。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_アドオンの設定&#34;&gt;アドオンの設定&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;多くの小さな 2.0 用のアドオンは、ユーザーがソースコードを編集してカスタマイズすることを必要としていました。2.1 では、これはもう良いアイデアではありません。ユーザーの変更が、更新の確認やダウンロードで上書きされるからです。2.1 では &lt;a href=&#34;#configuration&#34;&gt;設定&lt;/a&gt; システムを導入して、このような場合に対応するようになりました。2.0 も同様にサポートする必要がある場合には、次のようなコードが使えるでしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;if getattr(mw.addonsManager, &#34;getConfig&#34;, None):
    config = mw.addonManager.getConfig(__name__)
else:
    config = dict(optionA=123, optionB=456)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;hr&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_日本語版訳注&#34;&gt;日本語版訳注&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.1 Beta の更新履歴を知るには、&lt;a href=&#34;https://apps.ankiweb.net/docs/beta.html&#34;&gt;Anki 2.1 Beta&lt;/a&gt; が役立ちます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki 2.1 Beta 16 現在、Anki に同梱している Python のバージョンは &lt;code&gt;3.6.1&lt;/code&gt; です。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_日本語版更新履歴&#34;&gt;日本語版更新履歴&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;2017/08/27 Anki 2.1 Beta 13 準拠 (2017/08/26版) 初出&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017/08/29 Anki 2.1 Beta 14 準拠 (2017/08/28版)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017/08/31 Anki 2.1 Beta 15 準拠 (2017/08/31版)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017/09/03 Anki 2.1 Beta 15 準拠 (2017/09/02版)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017/09/06 Anki 2.1 Beta 16 準拠 (2017/09/06版)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;2017/09/10 Anki 2.1 Beta 16 準拠 (2017/09/10版)&lt;br&gt;&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>オンラインレッスンを強化する Anki の使い方</title>
      <link>http://rs.luminousspice.com/reinforce-online-lesson-with-anki/</link>
      <pubDate>Thu, 16 Feb 2017 12:26:59 +0900</pubDate>
      <guid>http://rs.luminousspice.com/reinforce-online-lesson-with-anki/</guid>
      <description>オンラインレッスンや言語交換 (ランゲージエクスチェンジ) での学習内容を効果的に復習して身につけるための Anki の使い方を説明します。</description>
      <content>&lt;div id=&#34;preamble&#34;&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;オンラインレッスンや言語交換 (ランゲージエクスチェンジ) での学習内容を効果的に復習して身につけるための Anki の使い方を説明します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_オンラインレッスンが言語学習を変えた&#34;&gt;オンラインレッスンが言語学習を変えた&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;動画チャットやボイスチャットのアプリケーションの利用率が上がり、オンラインで外国語のレッスンが簡単に受けられるようになりました。
さらに教師や言語交換パートナーをマッチングする SNS の完成度が高まったお陰で、自分の都合の良い時間に都合の良い場所で、世界中から自分の学習したい内容に見合った相手と外国語を練習できるようになりました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;私もポルトガル語、フランス語、英語の練習を毎日ネイティブスピーカーとできるようになりました。発音でも、朗読でも、作文でも、会話でも目的に適った方法を指定して練習できます。ゼロから始めた外国語でも進歩の実感がこれまでとは格段に違います。これは、とても素晴らしいことです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;一つ気になる点は、レッスンが簡単に受けられる分、復習がおろそかになりがちなことです。気を抜くとレッスンを受け流してしまい、大切な事項が中々身につかなくなります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;そこで、今回はオンラインレッスンの効果を上げるための Anki を活用した復習の仕方を紹介します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_音声データの復習&#34;&gt;音声データの復習&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Skype などでのビデオ通話や通常の通話でのオンラインレッスンの記録として一番使いやすいのは音声データです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;私は、相手から許可を取って発音練習、テキスト朗読、例文の読み上げや、ディクテーションなどで記録したデータを Anki のカードにしています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;発音やディクテーションといったフラッシュカードとはなじみのない練習方法でも、Anki を使って復習の管理ができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://rs.luminousspice.com/audio-stdout-into-anki-for-mac/&#34;&gt;Mac で再生中の音声を Anki に直接録音する&lt;/a&gt;で紹介した方法で通話アプリから音声を取り込んでいます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;私は、音声データは必要な部分だけを編集して使っています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_既に加工済みデータがある方へ&#34;&gt;既に加工済みデータがある方へ&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;すでに音声データを作って復習している場合は、分割したデータを大量に Anki に登録する方法は、&lt;a href=&#34;http://rs.luminousspice.com/learn-audio-material-with-anki/&#34;&gt;Anki を使って音声データ付き書籍の理解を深めよう&lt;/a&gt; を参考にすると良いでしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki への音声や画像データの基本的な一括登録方法は &lt;a href=&#34;http://rs.luminousspice.com/bulk-import-media-files-into-anki/&#34;&gt;画像、音声、動画などメディアファイルを Anki へ一括登録&lt;/a&gt; で説明してます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_通話以外での音声データの録音&#34;&gt;通話以外での音声データの録音&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;通話やチャットできない相手との発音やアクセント練習のための音声は、録音共有サービスの &lt;a href=&#34;https://clyp.it&#34;&gt;Clyp&lt;/a&gt; を使って交換しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Clyp の埋め込み機能は Anki 上で表示することができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/reinforce-online-lesson-clyp.png&#34; alt=&#34;Clyp データの表示例&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 1. Clyp データの表示例&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_チャットログの復習&#34;&gt;チャットログの復習&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;テキストチャットやメッセージ交換で言語交換しているとテキストのログデータが大量に溜まります。このデータも Anki に持ち込めば、漏らさずスケジュール管理して復習することができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Skype でのビデオ通話での文字データでの説明にテキストチャットを併用しています。またディクテーションや発音練習、聴き取り練習の際にも利用しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このデータも表計算ソフトやテキストエディタで TSV か CSV に加工して、&lt;a href=&#34;https://ankiweb.net/shared/info/1749692420&#34;&gt;Add Note From Clipboard&lt;/a&gt;というアドオンを使ってクリップボード経由で Anki に取り込んでいます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ファイルへの書き出しも不要で、ノートタイプやタグの指定もでき、レッスン後すぐにカード化できます。実際の手順は、&lt;a href=&#34;http://rs.luminousspice.com/how-to-use-shared-resources/&#34;&gt;Ankiの共有リソースを使ってみる&lt;/a&gt;で紹介している通りです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;また、このカードでは &lt;a href=&#34;https://ankiweb.net/shared/info/301952613&#34;&gt;AwesomeTTS&lt;/a&gt; というアドオンを使って、合成音声で読み上げをしています。設定方法は、&lt;a href=&#34;http://rs.luminousspice.com/how-to-edit-cards/&#34;&gt;Ankiのカード表示を編集する&lt;/a&gt;で説明しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki へのテキストデータの一括登録方法の基本は、&lt;a href=&#34;http://rs.luminousspice.com/how-to-import/&#34;&gt;Ankiにデータをまとめて取り込む&lt;/a&gt;で説明しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_添削データの復習&#34;&gt;添削データの復習&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://Lang-8.com&#34;&gt;Lang-8&lt;/a&gt; や &lt;a href=&#34;https://italki.com&#34;&gt;iTalki&lt;/a&gt; などの言語交換 SNS を使うとネイティブスピーカーから作文の添削を受けることができます。また、直接ネイティブスピーカーとレッスンしている方でも、作文の練習をしている方もいるでしょう。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;私は、作文だけに特化した言語パートナーと添削の交換をしています。
添削済みのデータも Anki に登録して復習しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;添削データの場合には、解説やメモを付けるので一括登録ではなく、文字を装飾しながら一件ずつ登録しています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;オンラインレッスンは Anki を使うと復習管理ができ、繰り返し練習できる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;発音練習やディクテーションのなど一人で復習するのが難しい練習も Anki を使うと可能になる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;テキストのログデータもアドオンを使うと簡単に Anki でカード化できる。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>Skype 音声を Anki に録音する</title>
      <link>http://rs.luminousspice.com/skype-audio-into-anki-for-mac/</link>
      <pubDate>Tue, 29 Nov 2016 09:44:27 +0900</pubDate>
      <guid>http://rs.luminousspice.com/skype-audio-into-anki-for-mac/</guid>
      <description>オンラインのインストラクターや言語交換パートナーなどとの Skype 会話中に録音して Anki のカードに直接取り込む方法を紹介します。</description>
      <content>&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;オンラインのインストラクターや言語交換パートナーなどとの Skype 会話中に録音して Anki のカードに直接取り込む方法を紹介します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この投稿は、Mac ユーザー限定の内容です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://rs.luminousspice.com/audio-stdout-into-anki-for-mac/&#34;&gt;Mac で再生中の音声を Anki に直接録音する&lt;/a&gt;では、Mac で再生した音声を Anki に直接取り込む方法を紹介しました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Skype での会話内容を Anki に取り込むには、さらに次のように Skype を設定します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;メニューバーから [設定] を選択し、[音声/ビデオ] タブを選択します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;ここで、スピーカー項目を [複数出力装置] に設定すると完了です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/skype-audio-preference.png&#34; alt=&#34;Skype 音声の設定例&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 1. Skype 音声の設定例&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;これで、Anki の録音機能を使って音声を登録できるようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Skype での会話を繰り返し練習して、効果を高めるために Anki をご活用ください。&lt;/p&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>YouTube の字幕付き動画を活用した Anki カードの作成</title>
      <link>http://rs.luminousspice.com/anki-card-from-youtobe-caption/</link>
      <pubDate>Sat, 28 May 2016 14:37:07 +0900</pubDate>
      <guid>http://rs.luminousspice.com/anki-card-from-youtobe-caption/</guid>
      <description>字幕付きの YouTube の番組データを使って Anki のカードを自動作成する YouTube Flashcards の使い方と、Anki の読み込み設定例、利用上の注意点、作成例について取り上げます。</description>
      <content>&lt;div id=&#34;preamble&#34;&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;字幕付きの YouTube の番組データを使って Anki のカードを自動作成する YouTube Flashcards の使い方と、Anki の読み込み設定例、利用上の注意点、作成例について取り上げます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_字幕付き動画から_anki_カードを作成&#34;&gt;字幕付き動画から Anki カードを作成&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;動画と字幕から Anki 用のカードを作成するアプリケーションとしては、Windows 版では、&lt;a href=&#34;http://subs2srs.sourceforge.net/&#34;&gt;subs2srs&lt;/a&gt;という非常に高機能なアプリケーションが Anki1 の頃から存在し、非常に有名です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;OS X などの他のプラットフォームで Anki を使っているユーザに取っては羨ましい限りだったのですが、ついにこの作業を自動化する &lt;a href=&#34;https://github.com/katspaugh/youtube-flashcards&#34;&gt;YouTube Flashcards&lt;/a&gt; が GitHub に公開されました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このアプリの機能をザックリと説明すると &lt;a href=&#34;https://github.com/rg3/youtube-dl/&#34;&gt;youtube-dl&lt;/a&gt; というアプリで動画と字幕をダウンロードし、その字幕のタイムラインの情報を元に &lt;a href=&#34;https://ffmpeg.org/&#34;&gt;FFmpeg&lt;/a&gt; で音声を分割し、画面ショットを取得し、さらに Anki に読み込むための TSV ファイルを作成してくれます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;動画をダウンロードしますが、カードには音声と画像を配置します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;字幕用ファイルのフォーマットは &lt;a href=&#34;https://www.w3.org/TR/webvtt1/&#34;&gt;WebVTT (Web Video Text Tracks)&lt;/a&gt; を使っています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;YouTube Flashcards を使うには、youtube-dl と FFmpeg がインストールされていることが前提です。OS X の場合は両方とも Homebrew から入手できます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_youtube_flashcards_の内容&#34;&gt;YouTube Flashcards の内容&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;YouTube Flashcards の構成は極めてシンプル、ダウンロード部分の作業を行う &lt;code&gt;download.sh&lt;/code&gt; とメディアファイルの加工を行う &lt;code&gt;extract.sh&lt;/code&gt; という二つのシェルスクリプトで構成しています。youtube-dl がサポートしているサイトなら、YouTube 以外でも利用できます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;内容も簡潔に記述しており、好みに応じて youtube-dl や FFmpeg のオプションを自分で記述できる容易なっています。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_メディアのダウンロード&#34;&gt;メディアのダウンロード&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;まず、動画ファイルと字幕ファイル (VTT) を取得します。ダウンロードしたファイルは &lt;code&gt;downloads&lt;/code&gt; フォルダに保存します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;メディアファイルと字幕ファイルの取得&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;./download.sh (メディアファイルのURL)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;画像ファイルが存在するか、どの言語で提供されているかについては youtube-dl を使って調べることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;利用可能な字幕ファイルの一覧の取得方法&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;youtube-dl --list-subs (メディアファイルのURL)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;利用可能なメディアファイルの一覧もダウンロード前に調べることができます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;利用可能なメディアファイルフォーマットの一覧の取得方法&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;youtube-dl -F (メディアファイルのURL)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;好みのフォーマットを入手するには &lt;code&gt;download.sh&lt;/code&gt; を編集して &lt;code&gt;-f&lt;/code&gt; で指定します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_anki_カード用にダウンロードファイルの加工&#34;&gt;Anki カード用にダウンロードファイルの加工&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;メディアファイルからの音声ファイルの切り出しと、画面キャプチャの取得、字幕ファイルからのテキストファイルの抽出を &lt;code&gt;extract.sh&lt;/code&gt; で行います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;メディアファイルの加工&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;./extract.sh (メディアファイルのパス) (字幕ファイルのパス) [(翻訳字幕ファイルのパス)] &amp;gt; (書き出す TSV ファイルのパス)&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;翻訳字幕ファイルのパスは、テキストを抽出するだけなので任意です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;加工した音声や画像は &lt;code&gt;output&lt;/code&gt; フォルダに保存します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;作成する TSV の内容は次のようになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;TSV ファイルの内容&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;原音声字幕	(翻訳字幕)	(画面キャプチャファイル名)	[sound:音声ファイル名]&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_tsv_ファイル利用の注意&#34;&gt;TSV ファイル利用の注意&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;字幕内の改行に HTML の &lt;code&gt;&amp;lt;br&amp;gt;&lt;/code&gt; タグを指定していますので、HTML を読み込む設定が必要になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;画像ファイルは、&lt;code&gt;&amp;lt;IMG&amp;gt;&lt;/code&gt; タグを設定していませんので、カードに画像を表示するには TSV を自分で加工してタグを付けるか、テンプレートの中でタグを設定する必要があります。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_anki_への読み込み&#34;&gt;Anki への読み込み&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;code&gt;output&lt;/code&gt; の中の動画や画像は、Anki のメディアフォルダに保存します。
書き出した TSV ファイルは、Anki のテキストファイル読み込み機能を使って読み込みます。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;オプションでは、[フィールドに HTML を利用する] を有効にします。
TSV ファイルは最低でも三つの列の内容がありますので、標準のノートタイプでは対応できません。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;私の場合は、基本ノートタイプに Picture フィールドを追加したノートタイプを作りました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;フィールドの対応表は次の通りです。表面に音声ファイルと画像ファイルを配置し、裏面に字幕の内容を表示する内容です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;テキストファイル読み込み設定例&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;フィールド1	Back
フィールド2	&amp;lt;無視&amp;gt;
フィールド3	Picture
フィールド4	Front&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_カードテンプレートの準備&#34;&gt;カードテンプレートの準備&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;さて、さらにカードテンプレートの編集が必要で、表面のテンプレートを次のように設定しました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;表面テンプレートの設定例&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;{{Front}}
&amp;lt;img src=&#34;{{Picture}}&#34;&amp;gt;&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_作成例とポイント&#34;&gt;作成例とポイント&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;完成品の一例を紹介しましょう。RussianPod101.com の番組を利用して作成したカードです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;imageblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;img src=&#34;http://rs.luminousspice.com/images/anki-card-from-youtube-caption.png&#34; alt=&#34;作成例&#34;&gt;
&lt;/div&gt;
&lt;div class=&#34;title&#34;&gt;図 1. 作成例&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;参考: &lt;a href=&#34;https://www.youtube.com/watch?v=htqx5YkTUms&#34;&gt;Weekly Russian Words with Katya - At the Aquarium&lt;/a&gt;&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_カード枚数の目安&#34;&gt;カード枚数の目安&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;この動画の長さは約二分で 24 枚のカードが自動作成できました。同じチャンネルの 8 分間の英語の番組では、120 枚になりました。また VOA の一分間のニュースフラッシュで 20 枚程度です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;実際に字幕ファイルを見れば、何枚カードができるかわかりますが、実用に適した番組の長さは数分程度が限界なのではないかと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect2&#34;&gt;
&lt;h3 id=&#34;_この方法で作ったカードを使ってみると&#34;&gt;この方法で作ったカードを使ってみると&lt;/h3&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;普段は YouTube の動画番組は、必要な箇所だけ&lt;a href=&#34;http://rs.luminousspice.com/audio-stdout-into-anki-for-mac/&#34;&gt;Mac で再生中の音声を Anki に直接録音する&lt;/a&gt;で紹介していた方法で直接録音しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;あらためていつも見ている番組を YouTube Flashcards で作ったカードと比較してみると、細かく区切った文章がある分、一つ一つの音を意識した聴き取りのカードに仕上がったのではないかと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;RussianPod101.com は、字幕にする音声を取捨選択していて、比較的切りのいいところで字幕が区切られています。番組によっては、特にニュースなどは、全ての音声を文字に書き起こすためか中途半端なところで音が切れて、人によっては気にするかもしれませんので、作成前に番組内容や字幕内容を確認することをお勧めします。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;手動で音声を区切るとどうしても繰り返し作業が多くなります。事前に正確なタイムラインを指定しているデータを使えるのは非常にありがたく、重宝します。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;YouTube Flashcards を使うと OS X や Linux でも YouTube の動画と字幕を使ったカードを作成できる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;ファイルのダウンロードや加工方法は、シェルスクリプトの編集で指定きる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;一分間あたりのカード枚数は　10-20 枚程度になるため、実用には番組の長さに注意。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;字幕の区切り方が番組の種類によって異なる。きれいに区切った音声が必要なら番組を選ぶ必要がある。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    </item>
    
    <item>
      <title>Anki における新規カード一分間トラップの分析</title>
      <link>http://rs.luminousspice.com/1min-trap-in-anki-learning/</link>
      <pubDate>Mon, 23 May 2016 13:14:21 +0900</pubDate>
      <guid>http://rs.luminousspice.com/1min-trap-in-anki-learning/</guid>
      <description>Anki で理解が不十分なカードを新規追加すると復習間隔が一分間で連続出題する状態から抜け出せなくなります。この一分間トラップを使って新規学習を評価する方法を紹介したいと思います。</description>
      <content>&lt;div id=&#34;preamble&#34;&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki で理解が不十分なカードを新規追加すると復習間隔が一分間で連続出題する状態から抜け出せなくなります。この一分間トラップを使って新規学習を評価する方法を紹介したいと思います。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_復習間隔一分に注目した理由&#34;&gt;復習間隔一分に注目した理由&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anki の処理を変更して直前の成功した間隔からやり直しを実現するアドオン &lt;a href=&#34;https://ankiweb.net/shared/info/1481634779&#34;&gt;Another Retreat&lt;/a&gt; を公開したらある人から、このアドオンを応用して復習間隔一分のデータを取れないかとの相談を受けました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;新規カードの学習で復習間隔一分で繰り返し失敗する &#34;1min Hell&#34; の分析に使うのに必要で、最初の一歩として定量的なデータが欲しいとのことでした。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;とりあえず Anki にデータを入れて、事前に十分な理解をせずにただ見る回数だけこなせばなんとかなるだろうという、SRS から逸脱した浅はかな使い方を自ら戒めるためにアドオンを作ってみました。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_一分間隔報告アドオン&#34;&gt;一分間隔報告アドオン&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;そこでクエリーを簡単に改造して復習履歴のデータを検索し、コレクション全体について間隔一分の学習回数とその比率を単語帳別に報告するアドオンを作りました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;このアドオンは AnkiWeb に &lt;a href=&#34;https://ankiweb.net/shared/info/1353526614&#34;&gt;1min Interval Report&lt;/a&gt; として公開しています。Anki 2.1.x Beta 11 以降でも動作します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;無サポート、無責任、無保証です。
大きなサイズのコレクションの場合は報告作成まで時間がかかります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;div class=&#34;title&#34;&gt;使い方&lt;/div&gt;
&lt;p&gt;メニューバーから [ツール] - [1min Interval Report] を選択すると新規ウィンドウに報告を表示します。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;div class=&#34;title&#34;&gt;表示内容&lt;/div&gt;
&lt;p&gt;左から単語帳名、一分間隔の回数、全セッション中の比率、新規セッションでの比率です。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;注目すべき数値は一番左の、新規セッション中の一分間隔の比率です。初期設定では、新規追加カードの学習ステップは 1 分と 10 分ですので、普通を二回押して終了した場合は 0%、一回もう一度、一回普通を押した場合は 50% になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;listingblock&#34;&gt;
&lt;div class=&#34;title&#34;&gt;出力例&lt;/div&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;1min Interval Report:

Deck	Count	% Total	% in Learn
Level1	 4618	 7.0	50.0
Level2	10569	15.0	67.0
Level31	11275	13.0	76.0
Level32	11169	15.0	75.0
Anatomy	  428	11.0	64.0
MWVB	 2801	18.0	54.0
MWDSA	　256	16.0	52.0&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_使用データの説明&#34;&gt;使用データの説明&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;実際の出力は単語帳名で並び替えますが、説明ために上からやさしい単語帳から難しいものになるように並べました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;先頭四行は同じ枚数の頻出別の単語帳です。Level31 と Level32 は同じ頻度ですがカード枚数を他の単語帳と同じにするために分けました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Anatomy とは、グレコローマンを語源とする解剖学用語のカードです。カードの構成は上の頻出用語集と全く同じです。上の単語帳の Level3 と重複した語彙が多いです。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;MWVBとは、&lt;a href=&#34;http://rs.luminousspice.com/learn-with-anki/&#34;&gt;暗記に強くなるために Anki から上手くサポートを得るには&lt;/a&gt;で学習モデルに利用した &lt;a  href=&#34;http://www.amazon.co.jp/gp/product/0877798559/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=0877798559&amp;linkCode=as2&amp;tag=rsls-22&#34;&gt;Merriam-Webster&#39;s Vocabulary Builder&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=rsls-22&amp;l=as2&amp;o=9&amp;a=0877798559&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; のデータです。カードにする前に十分な分量の文章を読むため、理解が進み一分間隔の学習が抑えられていることがわかります。また本文中で例文がたくさん掲載されているため、カードにも比較的長い文を掲載しています。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;MWDSA とは、&lt;a  href=&#34;http://www.amazon.co.jp/gp/product/0877799067/ref=as_li_ss_tl?ie=UTF8&amp;camp=247&amp;creative=7399&amp;creativeASIN=0877799067&amp;linkCode=as2&amp;tag=rsls-22&#34;&gt;The Merriam-Webster Dictionary of Synonyms and Antonyms&lt;/a&gt;&lt;img src=&#34;http://ir-jp.amazon-adsystem.com/e/ir?t=rsls-22&amp;l=as2&amp;o=9&amp;a=0877799067&#34; width=&#34;1&#34; height=&#34;1&#34; border=&#34;0&#34; alt=&#34;&#34; style=&#34;border:none !important; margin:0px !important;&#34; /&gt; です。同時に同じ意味の言葉を大量に知ることができ、事前に例文のたくさん読むことができます。カードの作りは MWVB と同じです。この単語帳だけ追加継続中です。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_データから読めたこと&#34;&gt;データから読めたこと&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;難易度が上がるに従って、一分間隔の比率も上がっています。これは期待通りの結果ですが、定量的なデータとして確認できました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;こちらは若干驚くべきことですが、相当な難語、古語、文語であっても、事前に親本の文章を読み、そこから例文を拾ったカードを作ると、最頻出語並に一分間隔の比率を抑えることができました。今日初めて知りました。ただし Anki で学習を始めるまでに本などで時間をかけて学習することになります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;literalblock&#34;&gt;
&lt;div class=&#34;content&#34;&gt;
&lt;pre&gt;Anki のカード学習の難しさと、元の教材の難しさは必ずしも一致しない。&lt;/pre&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;&lt;a href=&#34;http://rs.luminousspice.com/addon-ease-factor-histogram/&#34;&gt;Ease Factor Histogram 単語帳の健全性を診断するアドオン&lt;/a&gt; では、易しさの値の分布を使って単語帳全体としての教材の難しさ、カードの構成の適切さを評価しました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;実は、今回作ったアドオンは Ease Factor Histogram と相補的な関係にあることに気がつきました。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;Ease Factor Histogram は、復習の継続の困難さ評価する指標となり、このアドオン 1min Interval Report は、学習を開始する困難さを評価する指標になります。&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;特に 1min Interval Report は、カードを Anki で使う前に十分な準備をしたか、カードの構成は適切だったかなど新規学習を効果を高めるための視点を与えてくれます。&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_まとめ&#34;&gt;まとめ&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;ulist&#34;&gt;
&lt;ul&gt;
&lt;li&gt;
&lt;p&gt;新規学習での間隔一分の統計を取ると、Anki の新規学習の評価ができる。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;教材の難度は一分間隔の頻度に反映される。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;
&lt;p&gt;教材の事前準備やカードの構成によって、新規学習の難度を下げることができる。&lt;/p&gt;
&lt;/li&gt;
&lt;/ul&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;div class=&#34;sect1&#34;&gt;
&lt;h2 id=&#34;_更新情報&#34;&gt;更新情報&lt;/h2&gt;
&lt;div class=&#34;sectionbody&#34;&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;2016/05/23: 初出&lt;/p&gt;
&lt;/div&gt;
&lt;div class=&#34;paragraph&#34;&gt;
&lt;p&gt;2017/08/16: AnkiWeb へアドオン公開に伴い更新&lt;/p&gt;
&lt;/div&gt;
&lt;/div&gt;
&lt;/div&gt;
</content>
    </item>
    
  </channel>
</rss>
